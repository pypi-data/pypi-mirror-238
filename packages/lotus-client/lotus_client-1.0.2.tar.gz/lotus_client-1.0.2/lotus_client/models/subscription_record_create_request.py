# coding: utf-8

"""
    Lotus API

    Lotus is an open-core pricing and billing engine. We enable API companies to automate and optimize their custom usage-based pricing for any metric.  # noqa: E501

    OpenAPI spec version: 0.9.3
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class SubscriptionRecordCreateRequest(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'start_date': 'datetime',
        'end_date': 'datetime',
        'auto_renew': 'bool',
        'is_new': 'bool',
        'subscription_filters': 'list[SubscriptionFilterRequest]',
        'customer_id': 'str',
        'plan_id': 'str',
        'component_fixed_charges_initial_units': 'list[ComponentsFixedChargeInitialValueRequest]',
        'metadata': 'dict(str, object)'
    }

    attribute_map = {
        'start_date': 'start_date',
        'end_date': 'end_date',
        'auto_renew': 'auto_renew',
        'is_new': 'is_new',
        'subscription_filters': 'subscription_filters',
        'customer_id': 'customer_id',
        'plan_id': 'plan_id',
        'component_fixed_charges_initial_units': 'component_fixed_charges_initial_units',
        'metadata': 'metadata'
    }

    def __init__(self, start_date=None, end_date=None, auto_renew=None, is_new=None, subscription_filters=None, customer_id=None, plan_id=None, component_fixed_charges_initial_units=None, metadata=None):  # noqa: E501
        """SubscriptionRecordCreateRequest - a model defined in Swagger"""  # noqa: E501
        self._start_date = None
        self._end_date = None
        self._auto_renew = None
        self._is_new = None
        self._subscription_filters = None
        self._customer_id = None
        self._plan_id = None
        self._component_fixed_charges_initial_units = None
        self._metadata = None
        self.discriminator = None
        self.start_date = start_date
        if end_date is not None:
            self.end_date = end_date
        if auto_renew is not None:
            self.auto_renew = auto_renew
        if is_new is not None:
            self.is_new = is_new
        if subscription_filters is not None:
            self.subscription_filters = subscription_filters
        self.customer_id = customer_id
        if plan_id is not None:
            self.plan_id = plan_id
        if component_fixed_charges_initial_units is not None:
            self.component_fixed_charges_initial_units = component_fixed_charges_initial_units
        if metadata is not None:
            self.metadata = metadata

    @property
    def start_date(self):
        """Gets the start_date of this SubscriptionRecordCreateRequest.  # noqa: E501

        The date the subscription starts. This should be a string in YYYY-MM-DD format of the date in UTC time.  # noqa: E501

        :return: The start_date of this SubscriptionRecordCreateRequest.  # noqa: E501
        :rtype: datetime
        """
        return self._start_date

    @start_date.setter
    def start_date(self, start_date):
        """Sets the start_date of this SubscriptionRecordCreateRequest.

        The date the subscription starts. This should be a string in YYYY-MM-DD format of the date in UTC time.  # noqa: E501

        :param start_date: The start_date of this SubscriptionRecordCreateRequest.  # noqa: E501
        :type: datetime
        """
        if start_date is None:
            raise ValueError("Invalid value for `start_date`, must not be `None`")  # noqa: E501

        self._start_date = start_date

    @property
    def end_date(self):
        """Gets the end_date of this SubscriptionRecordCreateRequest.  # noqa: E501

        The date the subscription ends. This should be a string in YYYY-MM-DD format of the date in UTC time. If you don’t set it (recommended), we will use the information in the billing plan to automatically calculate this.  # noqa: E501

        :return: The end_date of this SubscriptionRecordCreateRequest.  # noqa: E501
        :rtype: datetime
        """
        return self._end_date

    @end_date.setter
    def end_date(self, end_date):
        """Sets the end_date of this SubscriptionRecordCreateRequest.

        The date the subscription ends. This should be a string in YYYY-MM-DD format of the date in UTC time. If you don’t set it (recommended), we will use the information in the billing plan to automatically calculate this.  # noqa: E501

        :param end_date: The end_date of this SubscriptionRecordCreateRequest.  # noqa: E501
        :type: datetime
        """

        self._end_date = end_date

    @property
    def auto_renew(self):
        """Gets the auto_renew of this SubscriptionRecordCreateRequest.  # noqa: E501

        Whether the subscription automatically renews. Defaults to true.  # noqa: E501

        :return: The auto_renew of this SubscriptionRecordCreateRequest.  # noqa: E501
        :rtype: bool
        """
        return self._auto_renew

    @auto_renew.setter
    def auto_renew(self, auto_renew):
        """Sets the auto_renew of this SubscriptionRecordCreateRequest.

        Whether the subscription automatically renews. Defaults to true.  # noqa: E501

        :param auto_renew: The auto_renew of this SubscriptionRecordCreateRequest.  # noqa: E501
        :type: bool
        """

        self._auto_renew = auto_renew

    @property
    def is_new(self):
        """Gets the is_new of this SubscriptionRecordCreateRequest.  # noqa: E501


        :return: The is_new of this SubscriptionRecordCreateRequest.  # noqa: E501
        :rtype: bool
        """
        return self._is_new

    @is_new.setter
    def is_new(self, is_new):
        """Sets the is_new of this SubscriptionRecordCreateRequest.


        :param is_new: The is_new of this SubscriptionRecordCreateRequest.  # noqa: E501
        :type: bool
        """

        self._is_new = is_new

    @property
    def subscription_filters(self):
        """Gets the subscription_filters of this SubscriptionRecordCreateRequest.  # noqa: E501

        Add filter key, value pairs that define which events will be applied to this plan subscription.  # noqa: E501

        :return: The subscription_filters of this SubscriptionRecordCreateRequest.  # noqa: E501
        :rtype: list[SubscriptionFilterRequest]
        """
        return self._subscription_filters

    @subscription_filters.setter
    def subscription_filters(self, subscription_filters):
        """Sets the subscription_filters of this SubscriptionRecordCreateRequest.

        Add filter key, value pairs that define which events will be applied to this plan subscription.  # noqa: E501

        :param subscription_filters: The subscription_filters of this SubscriptionRecordCreateRequest.  # noqa: E501
        :type: list[SubscriptionFilterRequest]
        """

        self._subscription_filters = subscription_filters

    @property
    def customer_id(self):
        """Gets the customer_id of this SubscriptionRecordCreateRequest.  # noqa: E501

        The id provided when creating the customer  # noqa: E501

        :return: The customer_id of this SubscriptionRecordCreateRequest.  # noqa: E501
        :rtype: str
        """
        return self._customer_id

    @customer_id.setter
    def customer_id(self, customer_id):
        """Sets the customer_id of this SubscriptionRecordCreateRequest.

        The id provided when creating the customer  # noqa: E501

        :param customer_id: The customer_id of this SubscriptionRecordCreateRequest.  # noqa: E501
        :type: str
        """
        if customer_id is None:
            raise ValueError("Invalid value for `customer_id`, must not be `None`")  # noqa: E501

        self._customer_id = customer_id

    @property
    def plan_id(self):
        """Gets the plan_id of this SubscriptionRecordCreateRequest.  # noqa: E501

        The Lotus plan_id, found in the billing plan object. We will make a best-effort attempt to find the correct plan version (matching preferred currencies, prioritizing custom plans), but if more than one plan version or no plan version matches these criteria this will return an error.  # noqa: E501

        :return: The plan_id of this SubscriptionRecordCreateRequest.  # noqa: E501
        :rtype: str
        """
        return self._plan_id

    @plan_id.setter
    def plan_id(self, plan_id):
        """Sets the plan_id of this SubscriptionRecordCreateRequest.

        The Lotus plan_id, found in the billing plan object. We will make a best-effort attempt to find the correct plan version (matching preferred currencies, prioritizing custom plans), but if more than one plan version or no plan version matches these criteria this will return an error.  # noqa: E501

        :param plan_id: The plan_id of this SubscriptionRecordCreateRequest.  # noqa: E501
        :type: str
        """

        self._plan_id = plan_id

    @property
    def component_fixed_charges_initial_units(self):
        """Gets the component_fixed_charges_initial_units of this SubscriptionRecordCreateRequest.  # noqa: E501

        The initial units for the plan components' prepaid fixed charges. This is only required if the plan has plan components where you did not specify the initial units.  # noqa: E501

        :return: The component_fixed_charges_initial_units of this SubscriptionRecordCreateRequest.  # noqa: E501
        :rtype: list[ComponentsFixedChargeInitialValueRequest]
        """
        return self._component_fixed_charges_initial_units

    @component_fixed_charges_initial_units.setter
    def component_fixed_charges_initial_units(self, component_fixed_charges_initial_units):
        """Sets the component_fixed_charges_initial_units of this SubscriptionRecordCreateRequest.

        The initial units for the plan components' prepaid fixed charges. This is only required if the plan has plan components where you did not specify the initial units.  # noqa: E501

        :param component_fixed_charges_initial_units: The component_fixed_charges_initial_units of this SubscriptionRecordCreateRequest.  # noqa: E501
        :type: list[ComponentsFixedChargeInitialValueRequest]
        """

        self._component_fixed_charges_initial_units = component_fixed_charges_initial_units

    @property
    def metadata(self):
        """Gets the metadata of this SubscriptionRecordCreateRequest.  # noqa: E501

        A JSON object containing additional information about the subscription.  # noqa: E501

        :return: The metadata of this SubscriptionRecordCreateRequest.  # noqa: E501
        :rtype: dict(str, object)
        """
        return self._metadata

    @metadata.setter
    def metadata(self, metadata):
        """Sets the metadata of this SubscriptionRecordCreateRequest.

        A JSON object containing additional information about the subscription.  # noqa: E501

        :param metadata: The metadata of this SubscriptionRecordCreateRequest.  # noqa: E501
        :type: dict(str, object)
        """

        self._metadata = metadata

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(SubscriptionRecordCreateRequest, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, SubscriptionRecordCreateRequest):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
