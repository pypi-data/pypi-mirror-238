# coding: utf-8

"""
    Lotus API

    Lotus is an open-core pricing and billing engine. We enable API companies to automate and optimize their custom usage-based pricing for any metric.  # noqa: E501

    OpenAPI spec version: 0.9.3
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class MetricDetail(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'property_name': 'str',
        'categorical_filters': 'list[CategoricalFilter]',
        'custom_sql': 'str',
        'event_name': 'str',
        'event_type': 'str',
        'metric_id': 'str',
        'granularity': 'str',
        'metric_name': 'str',
        'proration': 'str',
        'is_cost_metric': 'bool',
        'metric_type': 'str',
        'numeric_filters': 'list[NumericFilter]',
        'usage_aggregation_type': 'str',
        'billable_aggregation_type': 'str'
    }

    attribute_map = {
        'property_name': 'property_name',
        'categorical_filters': 'categorical_filters',
        'custom_sql': 'custom_sql',
        'event_name': 'event_name',
        'event_type': 'event_type',
        'metric_id': 'metric_id',
        'granularity': 'granularity',
        'metric_name': 'metric_name',
        'proration': 'proration',
        'is_cost_metric': 'is_cost_metric',
        'metric_type': 'metric_type',
        'numeric_filters': 'numeric_filters',
        'usage_aggregation_type': 'usage_aggregation_type',
        'billable_aggregation_type': 'billable_aggregation_type'
    }

    def __init__(self, property_name=None, categorical_filters=None, custom_sql=None, event_name=None, event_type=None, metric_id=None, granularity=None, metric_name=None, proration=None, is_cost_metric=None, metric_type=None, numeric_filters=None, usage_aggregation_type=None, billable_aggregation_type=None):  # noqa: E501
        """MetricDetail - a model defined in Swagger"""  # noqa: E501
        self._property_name = None
        self._categorical_filters = None
        self._custom_sql = None
        self._event_name = None
        self._event_type = None
        self._metric_id = None
        self._granularity = None
        self._metric_name = None
        self._proration = None
        self._is_cost_metric = None
        self._metric_type = None
        self._numeric_filters = None
        self._usage_aggregation_type = None
        self._billable_aggregation_type = None
        self.discriminator = None
        self.property_name = property_name
        self.categorical_filters = categorical_filters
        self.custom_sql = custom_sql
        self.event_name = event_name
        self.event_type = event_type
        self.metric_id = metric_id
        self.granularity = granularity
        self.metric_name = metric_name
        self.proration = proration
        self.is_cost_metric = is_cost_metric
        self.metric_type = metric_type
        self.numeric_filters = numeric_filters
        if usage_aggregation_type is not None:
            self.usage_aggregation_type = usage_aggregation_type
        if billable_aggregation_type is not None:
            self.billable_aggregation_type = billable_aggregation_type

    @property
    def property_name(self):
        """Gets the property_name of this MetricDetail.  # noqa: E501

        The name of the property of the event that should be used for this metric. Doesn't apply if the metric is of type 'counter' with an aggregation of count.  # noqa: E501

        :return: The property_name of this MetricDetail.  # noqa: E501
        :rtype: str
        """
        return self._property_name

    @property_name.setter
    def property_name(self, property_name):
        """Sets the property_name of this MetricDetail.

        The name of the property of the event that should be used for this metric. Doesn't apply if the metric is of type 'counter' with an aggregation of count.  # noqa: E501

        :param property_name: The property_name of this MetricDetail.  # noqa: E501
        :type: str
        """
        if property_name is None:
            raise ValueError("Invalid value for `property_name`, must not be `None`")  # noqa: E501

        self._property_name = property_name

    @property
    def categorical_filters(self):
        """Gets the categorical_filters of this MetricDetail.  # noqa: E501


        :return: The categorical_filters of this MetricDetail.  # noqa: E501
        :rtype: list[CategoricalFilter]
        """
        return self._categorical_filters

    @categorical_filters.setter
    def categorical_filters(self, categorical_filters):
        """Sets the categorical_filters of this MetricDetail.


        :param categorical_filters: The categorical_filters of this MetricDetail.  # noqa: E501
        :type: list[CategoricalFilter]
        """
        if categorical_filters is None:
            raise ValueError("Invalid value for `categorical_filters`, must not be `None`")  # noqa: E501

        self._categorical_filters = categorical_filters

    @property
    def custom_sql(self):
        """Gets the custom_sql of this MetricDetail.  # noqa: E501

        A custom SQL query that can be used to define the metric. Please refer to our documentation for more information.  # noqa: E501

        :return: The custom_sql of this MetricDetail.  # noqa: E501
        :rtype: str
        """
        return self._custom_sql

    @custom_sql.setter
    def custom_sql(self, custom_sql):
        """Sets the custom_sql of this MetricDetail.

        A custom SQL query that can be used to define the metric. Please refer to our documentation for more information.  # noqa: E501

        :param custom_sql: The custom_sql of this MetricDetail.  # noqa: E501
        :type: str
        """
        if custom_sql is None:
            raise ValueError("Invalid value for `custom_sql`, must not be `None`")  # noqa: E501

        self._custom_sql = custom_sql

    @property
    def event_name(self):
        """Gets the event_name of this MetricDetail.  # noqa: E501

        Name of the event that this metric is tracking.  # noqa: E501

        :return: The event_name of this MetricDetail.  # noqa: E501
        :rtype: str
        """
        return self._event_name

    @event_name.setter
    def event_name(self, event_name):
        """Sets the event_name of this MetricDetail.

        Name of the event that this metric is tracking.  # noqa: E501

        :param event_name: The event_name of this MetricDetail.  # noqa: E501
        :type: str
        """
        if event_name is None:
            raise ValueError("Invalid value for `event_name`, must not be `None`")  # noqa: E501

        self._event_name = event_name

    @property
    def event_type(self):
        """Gets the event_type of this MetricDetail.  # noqa: E501

        Used only for metrics of type 'gauge'. Please refer to our documentation for an explanation of the different types.  * `delta` - Delta * `total` - Total  # noqa: E501

        :return: The event_type of this MetricDetail.  # noqa: E501
        :rtype: str
        """
        return self._event_type

    @event_type.setter
    def event_type(self, event_type):
        """Sets the event_type of this MetricDetail.

        Used only for metrics of type 'gauge'. Please refer to our documentation for an explanation of the different types.  * `delta` - Delta * `total` - Total  # noqa: E501

        :param event_type: The event_type of this MetricDetail.  # noqa: E501
        :type: str
        """
        if event_type is None:
            raise ValueError("Invalid value for `event_type`, must not be `None`")  # noqa: E501
        allowed_values = ["delta", "total", ""]  # noqa: E501
        if event_type not in allowed_values:
            raise ValueError(
                "Invalid value for `event_type` ({0}), must be one of {1}"  # noqa: E501
                .format(event_type, allowed_values)
            )

        self._event_type = event_type

    @property
    def metric_id(self):
        """Gets the metric_id of this MetricDetail.  # noqa: E501


        :return: The metric_id of this MetricDetail.  # noqa: E501
        :rtype: str
        """
        return self._metric_id

    @metric_id.setter
    def metric_id(self, metric_id):
        """Sets the metric_id of this MetricDetail.


        :param metric_id: The metric_id of this MetricDetail.  # noqa: E501
        :type: str
        """
        if metric_id is None:
            raise ValueError("Invalid value for `metric_id`, must not be `None`")  # noqa: E501

        self._metric_id = metric_id

    @property
    def granularity(self):
        """Gets the granularity of this MetricDetail.  # noqa: E501

        The granularity of the metric. Only applies to metrics of type 'gauge' or 'rate'.  * `seconds` - Second * `minutes` - Minute * `hours` - Hour * `days` - Day * `months` - Month * `quarters` - Quarter * `years` - Year * `total` - Total  # noqa: E501

        :return: The granularity of this MetricDetail.  # noqa: E501
        :rtype: str
        """
        return self._granularity

    @granularity.setter
    def granularity(self, granularity):
        """Sets the granularity of this MetricDetail.

        The granularity of the metric. Only applies to metrics of type 'gauge' or 'rate'.  * `seconds` - Second * `minutes` - Minute * `hours` - Hour * `days` - Day * `months` - Month * `quarters` - Quarter * `years` - Year * `total` - Total  # noqa: E501

        :param granularity: The granularity of this MetricDetail.  # noqa: E501
        :type: str
        """
        if granularity is None:
            raise ValueError("Invalid value for `granularity`, must not be `None`")  # noqa: E501
        allowed_values = ["seconds", "minutes", "hours", "days", "months", "quarters", "years", "total", ""]  # noqa: E501
        if granularity not in allowed_values:
            raise ValueError(
                "Invalid value for `granularity` ({0}), must be one of {1}"  # noqa: E501
                .format(granularity, allowed_values)
            )

        self._granularity = granularity

    @property
    def metric_name(self):
        """Gets the metric_name of this MetricDetail.  # noqa: E501


        :return: The metric_name of this MetricDetail.  # noqa: E501
        :rtype: str
        """
        return self._metric_name

    @metric_name.setter
    def metric_name(self, metric_name):
        """Sets the metric_name of this MetricDetail.


        :param metric_name: The metric_name of this MetricDetail.  # noqa: E501
        :type: str
        """
        if metric_name is None:
            raise ValueError("Invalid value for `metric_name`, must not be `None`")  # noqa: E501

        self._metric_name = metric_name

    @property
    def proration(self):
        """Gets the proration of this MetricDetail.  # noqa: E501

        The proration of the metric. Only applies to metrics of type 'gauge'.  * `seconds` - Second * `minutes` - Minute * `hours` - Hour * `days` - Day * `months` - Month * `quarters` - Quarter * `years` - Year * `total` - Total  # noqa: E501

        :return: The proration of this MetricDetail.  # noqa: E501
        :rtype: str
        """
        return self._proration

    @proration.setter
    def proration(self, proration):
        """Sets the proration of this MetricDetail.

        The proration of the metric. Only applies to metrics of type 'gauge'.  * `seconds` - Second * `minutes` - Minute * `hours` - Hour * `days` - Day * `months` - Month * `quarters` - Quarter * `years` - Year * `total` - Total  # noqa: E501

        :param proration: The proration of this MetricDetail.  # noqa: E501
        :type: str
        """
        if proration is None:
            raise ValueError("Invalid value for `proration`, must not be `None`")  # noqa: E501
        allowed_values = ["seconds", "minutes", "hours", "days", "months", "quarters", "years", "total", ""]  # noqa: E501
        if proration not in allowed_values:
            raise ValueError(
                "Invalid value for `proration` ({0}), must be one of {1}"  # noqa: E501
                .format(proration, allowed_values)
            )

        self._proration = proration

    @property
    def is_cost_metric(self):
        """Gets the is_cost_metric of this MetricDetail.  # noqa: E501

        Whether or not this metric is a cost metric (used to track costs to your business).  # noqa: E501

        :return: The is_cost_metric of this MetricDetail.  # noqa: E501
        :rtype: bool
        """
        return self._is_cost_metric

    @is_cost_metric.setter
    def is_cost_metric(self, is_cost_metric):
        """Sets the is_cost_metric of this MetricDetail.

        Whether or not this metric is a cost metric (used to track costs to your business).  # noqa: E501

        :param is_cost_metric: The is_cost_metric of this MetricDetail.  # noqa: E501
        :type: bool
        """
        if is_cost_metric is None:
            raise ValueError("Invalid value for `is_cost_metric`, must not be `None`")  # noqa: E501

        self._is_cost_metric = is_cost_metric

    @property
    def metric_type(self):
        """Gets the metric_type of this MetricDetail.  # noqa: E501

        The type of metric that this is. Please refer to our documentation for an explanation of the different types.  * `counter` - Counter * `rate` - Rate * `custom` - Custom * `gauge` - Gauge  # noqa: E501

        :return: The metric_type of this MetricDetail.  # noqa: E501
        :rtype: str
        """
        return self._metric_type

    @metric_type.setter
    def metric_type(self, metric_type):
        """Sets the metric_type of this MetricDetail.

        The type of metric that this is. Please refer to our documentation for an explanation of the different types.  * `counter` - Counter * `rate` - Rate * `custom` - Custom * `gauge` - Gauge  # noqa: E501

        :param metric_type: The metric_type of this MetricDetail.  # noqa: E501
        :type: str
        """
        if metric_type is None:
            raise ValueError("Invalid value for `metric_type`, must not be `None`")  # noqa: E501
        allowed_values = ["counter", "rate", "custom", "gauge"]  # noqa: E501
        if metric_type not in allowed_values:
            raise ValueError(
                "Invalid value for `metric_type` ({0}), must be one of {1}"  # noqa: E501
                .format(metric_type, allowed_values)
            )

        self._metric_type = metric_type

    @property
    def numeric_filters(self):
        """Gets the numeric_filters of this MetricDetail.  # noqa: E501


        :return: The numeric_filters of this MetricDetail.  # noqa: E501
        :rtype: list[NumericFilter]
        """
        return self._numeric_filters

    @numeric_filters.setter
    def numeric_filters(self, numeric_filters):
        """Sets the numeric_filters of this MetricDetail.


        :param numeric_filters: The numeric_filters of this MetricDetail.  # noqa: E501
        :type: list[NumericFilter]
        """
        if numeric_filters is None:
            raise ValueError("Invalid value for `numeric_filters`, must not be `None`")  # noqa: E501

        self._numeric_filters = numeric_filters

    @property
    def usage_aggregation_type(self):
        """Gets the usage_aggregation_type of this MetricDetail.  # noqa: E501

        The type of aggregation that should be used for this metric. Please refer to our documentation for an explanation of the different types.  * `count` - Count * `sum` - Sum * `max` - Max * `unique` - Unique * `latest` - Latest * `average` - Average  # noqa: E501

        :return: The usage_aggregation_type of this MetricDetail.  # noqa: E501
        :rtype: str
        """
        return self._usage_aggregation_type

    @usage_aggregation_type.setter
    def usage_aggregation_type(self, usage_aggregation_type):
        """Sets the usage_aggregation_type of this MetricDetail.

        The type of aggregation that should be used for this metric. Please refer to our documentation for an explanation of the different types.  * `count` - Count * `sum` - Sum * `max` - Max * `unique` - Unique * `latest` - Latest * `average` - Average  # noqa: E501

        :param usage_aggregation_type: The usage_aggregation_type of this MetricDetail.  # noqa: E501
        :type: str
        """
        allowed_values = ["count", "sum", "max", "unique", "latest", "average"]  # noqa: E501
        if usage_aggregation_type not in allowed_values:
            raise ValueError(
                "Invalid value for `usage_aggregation_type` ({0}), must be one of {1}"  # noqa: E501
                .format(usage_aggregation_type, allowed_values)
            )

        self._usage_aggregation_type = usage_aggregation_type

    @property
    def billable_aggregation_type(self):
        """Gets the billable_aggregation_type of this MetricDetail.  # noqa: E501

        * `count` - Count * `sum` - Sum * `max` - Max * `unique` - Unique * `latest` - Latest * `average` - Average  # noqa: E501

        :return: The billable_aggregation_type of this MetricDetail.  # noqa: E501
        :rtype: str
        """
        return self._billable_aggregation_type

    @billable_aggregation_type.setter
    def billable_aggregation_type(self, billable_aggregation_type):
        """Sets the billable_aggregation_type of this MetricDetail.

        * `count` - Count * `sum` - Sum * `max` - Max * `unique` - Unique * `latest` - Latest * `average` - Average  # noqa: E501

        :param billable_aggregation_type: The billable_aggregation_type of this MetricDetail.  # noqa: E501
        :type: str
        """
        allowed_values = ["count", "sum", "max", "unique", "latest", "average", "", ""]  # noqa: E501
        if billable_aggregation_type not in allowed_values:
            raise ValueError(
                "Invalid value for `billable_aggregation_type` ({0}), must be one of {1}"  # noqa: E501
                .format(billable_aggregation_type, allowed_values)
            )

        self._billable_aggregation_type = billable_aggregation_type

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(MetricDetail, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, MetricDetail):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
