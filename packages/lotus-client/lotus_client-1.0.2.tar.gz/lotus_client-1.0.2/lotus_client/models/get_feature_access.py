# coding: utf-8

"""
    Lotus API

    Lotus is an open-core pricing and billing engine. We enable API companies to automate and optimize their custom usage-based pricing for any metric.  # noqa: E501

    OpenAPI spec version: 0.9.3
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class GetFeatureAccess(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'feature_name': 'str',
        'plan_id': 'str',
        'subscription_filters': 'list[SubscriptionFilter]',
        'access': 'bool'
    }

    attribute_map = {
        'feature_name': 'feature_name',
        'plan_id': 'plan_id',
        'subscription_filters': 'subscription_filters',
        'access': 'access'
    }

    def __init__(self, feature_name=None, plan_id=None, subscription_filters=None, access=None):  # noqa: E501
        """GetFeatureAccess - a model defined in Swagger"""  # noqa: E501
        self._feature_name = None
        self._plan_id = None
        self._subscription_filters = None
        self._access = None
        self.discriminator = None
        self.feature_name = feature_name
        self.plan_id = plan_id
        self.subscription_filters = subscription_filters
        self.access = access

    @property
    def feature_name(self):
        """Gets the feature_name of this GetFeatureAccess.  # noqa: E501

        Name of the feature to check access for.  # noqa: E501

        :return: The feature_name of this GetFeatureAccess.  # noqa: E501
        :rtype: str
        """
        return self._feature_name

    @feature_name.setter
    def feature_name(self, feature_name):
        """Sets the feature_name of this GetFeatureAccess.

        Name of the feature to check access for.  # noqa: E501

        :param feature_name: The feature_name of this GetFeatureAccess.  # noqa: E501
        :type: str
        """
        if feature_name is None:
            raise ValueError("Invalid value for `feature_name`, must not be `None`")  # noqa: E501

        self._feature_name = feature_name

    @property
    def plan_id(self):
        """Gets the plan_id of this GetFeatureAccess.  # noqa: E501

        The plan_id of the plan we are checking that has access to this feature.  # noqa: E501

        :return: The plan_id of this GetFeatureAccess.  # noqa: E501
        :rtype: str
        """
        return self._plan_id

    @plan_id.setter
    def plan_id(self, plan_id):
        """Sets the plan_id of this GetFeatureAccess.

        The plan_id of the plan we are checking that has access to this feature.  # noqa: E501

        :param plan_id: The plan_id of this GetFeatureAccess.  # noqa: E501
        :type: str
        """
        if plan_id is None:
            raise ValueError("Invalid value for `plan_id`, must not be `None`")  # noqa: E501

        self._plan_id = plan_id

    @property
    def subscription_filters(self):
        """Gets the subscription_filters of this GetFeatureAccess.  # noqa: E501

        The subscription filters that are applied to this plan's relationship with the customer. If your billing model does not have the ability multiple plans or subscriptions per customer, this is likely not relevant for you.  # noqa: E501

        :return: The subscription_filters of this GetFeatureAccess.  # noqa: E501
        :rtype: list[SubscriptionFilter]
        """
        return self._subscription_filters

    @subscription_filters.setter
    def subscription_filters(self, subscription_filters):
        """Sets the subscription_filters of this GetFeatureAccess.

        The subscription filters that are applied to this plan's relationship with the customer. If your billing model does not have the ability multiple plans or subscriptions per customer, this is likely not relevant for you.  # noqa: E501

        :param subscription_filters: The subscription_filters of this GetFeatureAccess.  # noqa: E501
        :type: list[SubscriptionFilter]
        """
        if subscription_filters is None:
            raise ValueError("Invalid value for `subscription_filters`, must not be `None`")  # noqa: E501

        self._subscription_filters = subscription_filters

    @property
    def access(self):
        """Gets the access of this GetFeatureAccess.  # noqa: E501

        Whether or not the plan has access to this feature. If your customer can have multiple plans or subscriptions, then you must check the 'access' across all returned plans to determine if the customer can access this feature.  # noqa: E501

        :return: The access of this GetFeatureAccess.  # noqa: E501
        :rtype: bool
        """
        return self._access

    @access.setter
    def access(self, access):
        """Sets the access of this GetFeatureAccess.

        Whether or not the plan has access to this feature. If your customer can have multiple plans or subscriptions, then you must check the 'access' across all returned plans to determine if the customer can access this feature.  # noqa: E501

        :param access: The access of this GetFeatureAccess.  # noqa: E501
        :type: bool
        """
        if access is None:
            raise ValueError("Invalid value for `access`, must not be `None`")  # noqa: E501

        self._access = access

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(GetFeatureAccess, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, GetFeatureAccess):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
