# coding: utf-8

"""
    Lotus API

    Lotus is an open-core pricing and billing engine. We enable API companies to automate and optimize their custom usage-based pricing for any metric.  # noqa: E501

    OpenAPI spec version: 0.9.3
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class Metric(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'metric_id': 'str',
        'event_name': 'str',
        'property_name': 'str',
        'aggregation_type': 'str',
        'granularity': 'str',
        'event_type': 'str',
        'metric_type': 'str',
        'metric_name': 'str',
        'numeric_filters': 'list[NumericFilter]',
        'categorical_filters': 'list[CategoricalFilter]',
        'is_cost_metric': 'bool',
        'custom_sql': 'str',
        'proration': 'str'
    }

    attribute_map = {
        'metric_id': 'metric_id',
        'event_name': 'event_name',
        'property_name': 'property_name',
        'aggregation_type': 'aggregation_type',
        'granularity': 'granularity',
        'event_type': 'event_type',
        'metric_type': 'metric_type',
        'metric_name': 'metric_name',
        'numeric_filters': 'numeric_filters',
        'categorical_filters': 'categorical_filters',
        'is_cost_metric': 'is_cost_metric',
        'custom_sql': 'custom_sql',
        'proration': 'proration'
    }

    def __init__(self, metric_id=None, event_name=None, property_name=None, aggregation_type=None, granularity=None, event_type=None, metric_type=None, metric_name=None, numeric_filters=None, categorical_filters=None, is_cost_metric=None, custom_sql=None, proration=None):  # noqa: E501
        """Metric - a model defined in Swagger"""  # noqa: E501
        self._metric_id = None
        self._event_name = None
        self._property_name = None
        self._aggregation_type = None
        self._granularity = None
        self._event_type = None
        self._metric_type = None
        self._metric_name = None
        self._numeric_filters = None
        self._categorical_filters = None
        self._is_cost_metric = None
        self._custom_sql = None
        self._proration = None
        self.discriminator = None
        self.metric_id = metric_id
        self.event_name = event_name
        self.property_name = property_name
        self.aggregation_type = aggregation_type
        self.granularity = granularity
        self.event_type = event_type
        self.metric_type = metric_type
        self.metric_name = metric_name
        self.numeric_filters = numeric_filters
        self.categorical_filters = categorical_filters
        self.is_cost_metric = is_cost_metric
        self.custom_sql = custom_sql
        self.proration = proration

    @property
    def metric_id(self):
        """Gets the metric_id of this Metric.  # noqa: E501


        :return: The metric_id of this Metric.  # noqa: E501
        :rtype: str
        """
        return self._metric_id

    @metric_id.setter
    def metric_id(self, metric_id):
        """Sets the metric_id of this Metric.


        :param metric_id: The metric_id of this Metric.  # noqa: E501
        :type: str
        """
        if metric_id is None:
            raise ValueError("Invalid value for `metric_id`, must not be `None`")  # noqa: E501

        self._metric_id = metric_id

    @property
    def event_name(self):
        """Gets the event_name of this Metric.  # noqa: E501

        Name of the event that this metric is tracking.  # noqa: E501

        :return: The event_name of this Metric.  # noqa: E501
        :rtype: str
        """
        return self._event_name

    @event_name.setter
    def event_name(self, event_name):
        """Sets the event_name of this Metric.

        Name of the event that this metric is tracking.  # noqa: E501

        :param event_name: The event_name of this Metric.  # noqa: E501
        :type: str
        """
        if event_name is None:
            raise ValueError("Invalid value for `event_name`, must not be `None`")  # noqa: E501

        self._event_name = event_name

    @property
    def property_name(self):
        """Gets the property_name of this Metric.  # noqa: E501

        The name of the property of the event that should be used for this metric. Doesn't apply if the metric is of type 'counter' with an aggregation of count.  # noqa: E501

        :return: The property_name of this Metric.  # noqa: E501
        :rtype: str
        """
        return self._property_name

    @property_name.setter
    def property_name(self, property_name):
        """Sets the property_name of this Metric.

        The name of the property of the event that should be used for this metric. Doesn't apply if the metric is of type 'counter' with an aggregation of count.  # noqa: E501

        :param property_name: The property_name of this Metric.  # noqa: E501
        :type: str
        """
        if property_name is None:
            raise ValueError("Invalid value for `property_name`, must not be `None`")  # noqa: E501

        self._property_name = property_name

    @property
    def aggregation_type(self):
        """Gets the aggregation_type of this Metric.  # noqa: E501


        :return: The aggregation_type of this Metric.  # noqa: E501
        :rtype: str
        """
        return self._aggregation_type

    @aggregation_type.setter
    def aggregation_type(self, aggregation_type):
        """Sets the aggregation_type of this Metric.


        :param aggregation_type: The aggregation_type of this Metric.  # noqa: E501
        :type: str
        """
        if aggregation_type is None:
            raise ValueError("Invalid value for `aggregation_type`, must not be `None`")  # noqa: E501

        self._aggregation_type = aggregation_type

    @property
    def granularity(self):
        """Gets the granularity of this Metric.  # noqa: E501

        The granularity of the metric. Only applies to metrics of type 'gauge' or 'rate'.  * `seconds` - Second * `minutes` - Minute * `hours` - Hour * `days` - Day * `months` - Month * `quarters` - Quarter * `years` - Year * `total` - Total  # noqa: E501

        :return: The granularity of this Metric.  # noqa: E501
        :rtype: str
        """
        return self._granularity

    @granularity.setter
    def granularity(self, granularity):
        """Sets the granularity of this Metric.

        The granularity of the metric. Only applies to metrics of type 'gauge' or 'rate'.  * `seconds` - Second * `minutes` - Minute * `hours` - Hour * `days` - Day * `months` - Month * `quarters` - Quarter * `years` - Year * `total` - Total  # noqa: E501

        :param granularity: The granularity of this Metric.  # noqa: E501
        :type: str
        """
        if granularity is None:
            raise ValueError("Invalid value for `granularity`, must not be `None`")  # noqa: E501
        allowed_values = ["seconds", "minutes", "hours", "days", "months", "quarters", "years", "total", ""]  # noqa: E501
        if granularity not in allowed_values:
            raise ValueError(
                "Invalid value for `granularity` ({0}), must be one of {1}"  # noqa: E501
                .format(granularity, allowed_values)
            )

        self._granularity = granularity

    @property
    def event_type(self):
        """Gets the event_type of this Metric.  # noqa: E501

        Used only for metrics of type 'gauge'. Please refer to our documentation for an explanation of the different types.  * `delta` - Delta * `total` - Total  # noqa: E501

        :return: The event_type of this Metric.  # noqa: E501
        :rtype: str
        """
        return self._event_type

    @event_type.setter
    def event_type(self, event_type):
        """Sets the event_type of this Metric.

        Used only for metrics of type 'gauge'. Please refer to our documentation for an explanation of the different types.  * `delta` - Delta * `total` - Total  # noqa: E501

        :param event_type: The event_type of this Metric.  # noqa: E501
        :type: str
        """
        if event_type is None:
            raise ValueError("Invalid value for `event_type`, must not be `None`")  # noqa: E501
        allowed_values = ["delta", "total", ""]  # noqa: E501
        if event_type not in allowed_values:
            raise ValueError(
                "Invalid value for `event_type` ({0}), must be one of {1}"  # noqa: E501
                .format(event_type, allowed_values)
            )

        self._event_type = event_type

    @property
    def metric_type(self):
        """Gets the metric_type of this Metric.  # noqa: E501

        The type of metric that this is. Please refer to our documentation for an explanation of the different types.  * `counter` - Counter * `rate` - Rate * `custom` - Custom * `gauge` - Gauge  # noqa: E501

        :return: The metric_type of this Metric.  # noqa: E501
        :rtype: str
        """
        return self._metric_type

    @metric_type.setter
    def metric_type(self, metric_type):
        """Sets the metric_type of this Metric.

        The type of metric that this is. Please refer to our documentation for an explanation of the different types.  * `counter` - Counter * `rate` - Rate * `custom` - Custom * `gauge` - Gauge  # noqa: E501

        :param metric_type: The metric_type of this Metric.  # noqa: E501
        :type: str
        """
        if metric_type is None:
            raise ValueError("Invalid value for `metric_type`, must not be `None`")  # noqa: E501
        allowed_values = ["counter", "rate", "custom", "gauge"]  # noqa: E501
        if metric_type not in allowed_values:
            raise ValueError(
                "Invalid value for `metric_type` ({0}), must be one of {1}"  # noqa: E501
                .format(metric_type, allowed_values)
            )

        self._metric_type = metric_type

    @property
    def metric_name(self):
        """Gets the metric_name of this Metric.  # noqa: E501


        :return: The metric_name of this Metric.  # noqa: E501
        :rtype: str
        """
        return self._metric_name

    @metric_name.setter
    def metric_name(self, metric_name):
        """Sets the metric_name of this Metric.


        :param metric_name: The metric_name of this Metric.  # noqa: E501
        :type: str
        """
        if metric_name is None:
            raise ValueError("Invalid value for `metric_name`, must not be `None`")  # noqa: E501

        self._metric_name = metric_name

    @property
    def numeric_filters(self):
        """Gets the numeric_filters of this Metric.  # noqa: E501


        :return: The numeric_filters of this Metric.  # noqa: E501
        :rtype: list[NumericFilter]
        """
        return self._numeric_filters

    @numeric_filters.setter
    def numeric_filters(self, numeric_filters):
        """Sets the numeric_filters of this Metric.


        :param numeric_filters: The numeric_filters of this Metric.  # noqa: E501
        :type: list[NumericFilter]
        """
        if numeric_filters is None:
            raise ValueError("Invalid value for `numeric_filters`, must not be `None`")  # noqa: E501

        self._numeric_filters = numeric_filters

    @property
    def categorical_filters(self):
        """Gets the categorical_filters of this Metric.  # noqa: E501


        :return: The categorical_filters of this Metric.  # noqa: E501
        :rtype: list[CategoricalFilter]
        """
        return self._categorical_filters

    @categorical_filters.setter
    def categorical_filters(self, categorical_filters):
        """Sets the categorical_filters of this Metric.


        :param categorical_filters: The categorical_filters of this Metric.  # noqa: E501
        :type: list[CategoricalFilter]
        """
        if categorical_filters is None:
            raise ValueError("Invalid value for `categorical_filters`, must not be `None`")  # noqa: E501

        self._categorical_filters = categorical_filters

    @property
    def is_cost_metric(self):
        """Gets the is_cost_metric of this Metric.  # noqa: E501

        Whether or not this metric is a cost metric (used to track costs to your business).  # noqa: E501

        :return: The is_cost_metric of this Metric.  # noqa: E501
        :rtype: bool
        """
        return self._is_cost_metric

    @is_cost_metric.setter
    def is_cost_metric(self, is_cost_metric):
        """Sets the is_cost_metric of this Metric.

        Whether or not this metric is a cost metric (used to track costs to your business).  # noqa: E501

        :param is_cost_metric: The is_cost_metric of this Metric.  # noqa: E501
        :type: bool
        """
        if is_cost_metric is None:
            raise ValueError("Invalid value for `is_cost_metric`, must not be `None`")  # noqa: E501

        self._is_cost_metric = is_cost_metric

    @property
    def custom_sql(self):
        """Gets the custom_sql of this Metric.  # noqa: E501

        A custom SQL query that can be used to define the metric. Please refer to our documentation for more information.  # noqa: E501

        :return: The custom_sql of this Metric.  # noqa: E501
        :rtype: str
        """
        return self._custom_sql

    @custom_sql.setter
    def custom_sql(self, custom_sql):
        """Sets the custom_sql of this Metric.

        A custom SQL query that can be used to define the metric. Please refer to our documentation for more information.  # noqa: E501

        :param custom_sql: The custom_sql of this Metric.  # noqa: E501
        :type: str
        """
        if custom_sql is None:
            raise ValueError("Invalid value for `custom_sql`, must not be `None`")  # noqa: E501

        self._custom_sql = custom_sql

    @property
    def proration(self):
        """Gets the proration of this Metric.  # noqa: E501

        The proration of the metric. Only applies to metrics of type 'gauge'.  * `seconds` - Second * `minutes` - Minute * `hours` - Hour * `days` - Day * `months` - Month * `quarters` - Quarter * `years` - Year * `total` - Total  # noqa: E501

        :return: The proration of this Metric.  # noqa: E501
        :rtype: str
        """
        return self._proration

    @proration.setter
    def proration(self, proration):
        """Sets the proration of this Metric.

        The proration of the metric. Only applies to metrics of type 'gauge'.  * `seconds` - Second * `minutes` - Minute * `hours` - Hour * `days` - Day * `months` - Month * `quarters` - Quarter * `years` - Year * `total` - Total  # noqa: E501

        :param proration: The proration of this Metric.  # noqa: E501
        :type: str
        """
        if proration is None:
            raise ValueError("Invalid value for `proration`, must not be `None`")  # noqa: E501
        allowed_values = ["seconds", "minutes", "hours", "days", "months", "quarters", "years", "total", ""]  # noqa: E501
        if proration not in allowed_values:
            raise ValueError(
                "Invalid value for `proration` ({0}), must be one of {1}"  # noqa: E501
                .format(proration, allowed_values)
            )

        self._proration = proration

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(Metric, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Metric):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
