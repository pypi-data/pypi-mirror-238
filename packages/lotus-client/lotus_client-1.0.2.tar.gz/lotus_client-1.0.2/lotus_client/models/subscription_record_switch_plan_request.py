# coding: utf-8

"""
    Lotus API

    Lotus is an open-core pricing and billing engine. We enable API companies to automate and optimize their custom usage-based pricing for any metric.  # noqa: E501

    OpenAPI spec version: 0.9.3
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class SubscriptionRecordSwitchPlanRequest(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'switch_plan_id': 'str',
        'invoicing_behavior': 'str',
        'usage_behavior': 'str',
        'component_fixed_charges_initial_units': 'list[ComponentsFixedChargeInitialValueRequest]'
    }

    attribute_map = {
        'switch_plan_id': 'switch_plan_id',
        'invoicing_behavior': 'invoicing_behavior',
        'usage_behavior': 'usage_behavior',
        'component_fixed_charges_initial_units': 'component_fixed_charges_initial_units'
    }

    def __init__(self, switch_plan_id=None, invoicing_behavior='invoice_now', usage_behavior='transfer_to_new_subscription', component_fixed_charges_initial_units=None):  # noqa: E501
        """SubscriptionRecordSwitchPlanRequest - a model defined in Swagger"""  # noqa: E501
        self._switch_plan_id = None
        self._invoicing_behavior = None
        self._usage_behavior = None
        self._component_fixed_charges_initial_units = None
        self.discriminator = None
        if switch_plan_id is not None:
            self.switch_plan_id = switch_plan_id
        if invoicing_behavior is not None:
            self.invoicing_behavior = invoicing_behavior
        if usage_behavior is not None:
            self.usage_behavior = usage_behavior
        if component_fixed_charges_initial_units is not None:
            self.component_fixed_charges_initial_units = component_fixed_charges_initial_units

    @property
    def switch_plan_id(self):
        """Gets the switch_plan_id of this SubscriptionRecordSwitchPlanRequest.  # noqa: E501

        The new plan to switch to.  # noqa: E501

        :return: The switch_plan_id of this SubscriptionRecordSwitchPlanRequest.  # noqa: E501
        :rtype: str
        """
        return self._switch_plan_id

    @switch_plan_id.setter
    def switch_plan_id(self, switch_plan_id):
        """Sets the switch_plan_id of this SubscriptionRecordSwitchPlanRequest.

        The new plan to switch to.  # noqa: E501

        :param switch_plan_id: The switch_plan_id of this SubscriptionRecordSwitchPlanRequest.  # noqa: E501
        :type: str
        """

        self._switch_plan_id = switch_plan_id

    @property
    def invoicing_behavior(self):
        """Gets the invoicing_behavior of this SubscriptionRecordSwitchPlanRequest.  # noqa: E501

        The invoicing behavior to use when replacing the plan. Invoice now will invoice the customer for the prorated difference of the old plan and the new plan, whereas add_to_next_invoice will wait until the end of the subscription to do the calculation.  * `add_to_next_invoice` - Add to Next Invoice * `invoice_now` - Invoice Now  # noqa: E501

        :return: The invoicing_behavior of this SubscriptionRecordSwitchPlanRequest.  # noqa: E501
        :rtype: str
        """
        return self._invoicing_behavior

    @invoicing_behavior.setter
    def invoicing_behavior(self, invoicing_behavior):
        """Sets the invoicing_behavior of this SubscriptionRecordSwitchPlanRequest.

        The invoicing behavior to use when replacing the plan. Invoice now will invoice the customer for the prorated difference of the old plan and the new plan, whereas add_to_next_invoice will wait until the end of the subscription to do the calculation.  * `add_to_next_invoice` - Add to Next Invoice * `invoice_now` - Invoice Now  # noqa: E501

        :param invoicing_behavior: The invoicing_behavior of this SubscriptionRecordSwitchPlanRequest.  # noqa: E501
        :type: str
        """
        allowed_values = ["add_to_next_invoice", "invoice_now"]  # noqa: E501
        if invoicing_behavior not in allowed_values:
            raise ValueError(
                "Invalid value for `invoicing_behavior` ({0}), must be one of {1}"  # noqa: E501
                .format(invoicing_behavior, allowed_values)
            )

        self._invoicing_behavior = invoicing_behavior

    @property
    def usage_behavior(self):
        """Gets the usage_behavior of this SubscriptionRecordSwitchPlanRequest.  # noqa: E501

        The usage behavior to use when replacing the plan. Transfer to new subscription will transfer the usage from the old subscription to the new subscription, whereas keep_separate will reset the usage to 0 for the new subscription, while keeping the old usage on the old subscription and charging for that appropriately at the end of the month.  * `transfer_to_new_subscription` - Transfer to New Subscription * `keep_separate` - Keep Separate  # noqa: E501

        :return: The usage_behavior of this SubscriptionRecordSwitchPlanRequest.  # noqa: E501
        :rtype: str
        """
        return self._usage_behavior

    @usage_behavior.setter
    def usage_behavior(self, usage_behavior):
        """Sets the usage_behavior of this SubscriptionRecordSwitchPlanRequest.

        The usage behavior to use when replacing the plan. Transfer to new subscription will transfer the usage from the old subscription to the new subscription, whereas keep_separate will reset the usage to 0 for the new subscription, while keeping the old usage on the old subscription and charging for that appropriately at the end of the month.  * `transfer_to_new_subscription` - Transfer to New Subscription * `keep_separate` - Keep Separate  # noqa: E501

        :param usage_behavior: The usage_behavior of this SubscriptionRecordSwitchPlanRequest.  # noqa: E501
        :type: str
        """
        allowed_values = ["transfer_to_new_subscription", "keep_separate"]  # noqa: E501
        if usage_behavior not in allowed_values:
            raise ValueError(
                "Invalid value for `usage_behavior` ({0}), must be one of {1}"  # noqa: E501
                .format(usage_behavior, allowed_values)
            )

        self._usage_behavior = usage_behavior

    @property
    def component_fixed_charges_initial_units(self):
        """Gets the component_fixed_charges_initial_units of this SubscriptionRecordSwitchPlanRequest.  # noqa: E501

        The initial units for the plan components' prepaid fixed charges. In the context of swithciong plans, this is only required if the new plan has a component the old plan did not have, that has a prepaid charge, that deos not have a default.  # noqa: E501

        :return: The component_fixed_charges_initial_units of this SubscriptionRecordSwitchPlanRequest.  # noqa: E501
        :rtype: list[ComponentsFixedChargeInitialValueRequest]
        """
        return self._component_fixed_charges_initial_units

    @component_fixed_charges_initial_units.setter
    def component_fixed_charges_initial_units(self, component_fixed_charges_initial_units):
        """Sets the component_fixed_charges_initial_units of this SubscriptionRecordSwitchPlanRequest.

        The initial units for the plan components' prepaid fixed charges. In the context of swithciong plans, this is only required if the new plan has a component the old plan did not have, that has a prepaid charge, that deos not have a default.  # noqa: E501

        :param component_fixed_charges_initial_units: The component_fixed_charges_initial_units of this SubscriptionRecordSwitchPlanRequest.  # noqa: E501
        :type: list[ComponentsFixedChargeInitialValueRequest]
        """

        self._component_fixed_charges_initial_units = component_fixed_charges_initial_units

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(SubscriptionRecordSwitchPlanRequest, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, SubscriptionRecordSwitchPlanRequest):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
