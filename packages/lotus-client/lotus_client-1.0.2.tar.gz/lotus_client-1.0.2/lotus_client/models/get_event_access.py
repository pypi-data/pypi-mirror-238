# coding: utf-8

"""
    Lotus API

    Lotus is an open-core pricing and billing engine. We enable API companies to automate and optimize their custom usage-based pricing for any metric.  # noqa: E501

    OpenAPI spec version: 0.9.3
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class GetEventAccess(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'plan_id': 'str',
        'subscription_filters': 'list[SubscriptionFilter]',
        'usage_per_component': 'list[ComponentUsage]'
    }

    attribute_map = {
        'plan_id': 'plan_id',
        'subscription_filters': 'subscription_filters',
        'usage_per_component': 'usage_per_component'
    }

    def __init__(self, plan_id=None, subscription_filters=None, usage_per_component=None):  # noqa: E501
        """GetEventAccess - a model defined in Swagger"""  # noqa: E501
        self._plan_id = None
        self._subscription_filters = None
        self._usage_per_component = None
        self.discriminator = None
        self.plan_id = plan_id
        self.subscription_filters = subscription_filters
        self.usage_per_component = usage_per_component

    @property
    def plan_id(self):
        """Gets the plan_id of this GetEventAccess.  # noqa: E501

        The plan_id of the plan we are checking that has access to this feature.  # noqa: E501

        :return: The plan_id of this GetEventAccess.  # noqa: E501
        :rtype: str
        """
        return self._plan_id

    @plan_id.setter
    def plan_id(self, plan_id):
        """Sets the plan_id of this GetEventAccess.

        The plan_id of the plan we are checking that has access to this feature.  # noqa: E501

        :param plan_id: The plan_id of this GetEventAccess.  # noqa: E501
        :type: str
        """
        if plan_id is None:
            raise ValueError("Invalid value for `plan_id`, must not be `None`")  # noqa: E501

        self._plan_id = plan_id

    @property
    def subscription_filters(self):
        """Gets the subscription_filters of this GetEventAccess.  # noqa: E501

        The subscription filters that are applied to this plan's relationship with the customer. If your billing model does not have the ability multiple plans or subscriptions per customer, this is likely not relevant for you.  # noqa: E501

        :return: The subscription_filters of this GetEventAccess.  # noqa: E501
        :rtype: list[SubscriptionFilter]
        """
        return self._subscription_filters

    @subscription_filters.setter
    def subscription_filters(self, subscription_filters):
        """Sets the subscription_filters of this GetEventAccess.

        The subscription filters that are applied to this plan's relationship with the customer. If your billing model does not have the ability multiple plans or subscriptions per customer, this is likely not relevant for you.  # noqa: E501

        :param subscription_filters: The subscription_filters of this GetEventAccess.  # noqa: E501
        :type: list[SubscriptionFilter]
        """
        if subscription_filters is None:
            raise ValueError("Invalid value for `subscription_filters`, must not be `None`")  # noqa: E501

        self._subscription_filters = subscription_filters

    @property
    def usage_per_component(self):
        """Gets the usage_per_component of this GetEventAccess.  # noqa: E501

        The usage of each component of the plan the customer is on. Only components that match the request will be included: If metric_id is provided, this will be a list of length 1. If event_name is provided, this will be a list of length 1 or more depending on how many components of the customer's plan use this event.  # noqa: E501

        :return: The usage_per_component of this GetEventAccess.  # noqa: E501
        :rtype: list[ComponentUsage]
        """
        return self._usage_per_component

    @usage_per_component.setter
    def usage_per_component(self, usage_per_component):
        """Sets the usage_per_component of this GetEventAccess.

        The usage of each component of the plan the customer is on. Only components that match the request will be included: If metric_id is provided, this will be a list of length 1. If event_name is provided, this will be a list of length 1 or more depending on how many components of the customer's plan use this event.  # noqa: E501

        :param usage_per_component: The usage_per_component of this GetEventAccess.  # noqa: E501
        :type: list[ComponentUsage]
        """
        if usage_per_component is None:
            raise ValueError("Invalid value for `usage_per_component`, must not be `None`")  # noqa: E501

        self._usage_per_component = usage_per_component

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(GetEventAccess, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, GetEventAccess):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
