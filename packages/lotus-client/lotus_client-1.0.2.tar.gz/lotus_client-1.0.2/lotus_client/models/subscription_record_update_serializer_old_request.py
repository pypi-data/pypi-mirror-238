# coding: utf-8

"""
    Lotus API

    Lotus is an open-core pricing and billing engine. We enable API companies to automate and optimize their custom usage-based pricing for any metric.  # noqa: E501

    OpenAPI spec version: 0.9.3
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class SubscriptionRecordUpdateSerializerOldRequest(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'replace_plan_id': 'str',
        'invoicing_behavior': 'str',
        'usage_behavior': 'str',
        'turn_off_auto_renew': 'bool',
        'end_date': 'datetime'
    }

    attribute_map = {
        'replace_plan_id': 'replace_plan_id',
        'invoicing_behavior': 'invoicing_behavior',
        'usage_behavior': 'usage_behavior',
        'turn_off_auto_renew': 'turn_off_auto_renew',
        'end_date': 'end_date'
    }

    def __init__(self, replace_plan_id=None, invoicing_behavior='invoice_now', usage_behavior='transfer_to_new_subscription', turn_off_auto_renew=None, end_date=None):  # noqa: E501
        """SubscriptionRecordUpdateSerializerOldRequest - a model defined in Swagger"""  # noqa: E501
        self._replace_plan_id = None
        self._invoicing_behavior = None
        self._usage_behavior = None
        self._turn_off_auto_renew = None
        self._end_date = None
        self.discriminator = None
        if replace_plan_id is not None:
            self.replace_plan_id = replace_plan_id
        if invoicing_behavior is not None:
            self.invoicing_behavior = invoicing_behavior
        if usage_behavior is not None:
            self.usage_behavior = usage_behavior
        if turn_off_auto_renew is not None:
            self.turn_off_auto_renew = turn_off_auto_renew
        if end_date is not None:
            self.end_date = end_date

    @property
    def replace_plan_id(self):
        """Gets the replace_plan_id of this SubscriptionRecordUpdateSerializerOldRequest.  # noqa: E501

        [DEPRECATED] Will currently perform a best-effort attempt to find the correct plan version to replace the current plan with. If more than one plan version matches the criteria, this will return an error. Use the change_plan method of a subscription instance instead.  # noqa: E501

        :return: The replace_plan_id of this SubscriptionRecordUpdateSerializerOldRequest.  # noqa: E501
        :rtype: str
        """
        return self._replace_plan_id

    @replace_plan_id.setter
    def replace_plan_id(self, replace_plan_id):
        """Sets the replace_plan_id of this SubscriptionRecordUpdateSerializerOldRequest.

        [DEPRECATED] Will currently perform a best-effort attempt to find the correct plan version to replace the current plan with. If more than one plan version matches the criteria, this will return an error. Use the change_plan method of a subscription instance instead.  # noqa: E501

        :param replace_plan_id: The replace_plan_id of this SubscriptionRecordUpdateSerializerOldRequest.  # noqa: E501
        :type: str
        """

        self._replace_plan_id = replace_plan_id

    @property
    def invoicing_behavior(self):
        """Gets the invoicing_behavior of this SubscriptionRecordUpdateSerializerOldRequest.  # noqa: E501

        The invoicing behavior to use when replacing the plan. Invoice now will invoice the customer for the prorated difference of the old plan and the new plan, whereas add_to_next_invoice will wait until the end of the subscription to do the calculation.  * `add_to_next_invoice` - Add to Next Invoice * `invoice_now` - Invoice Now  # noqa: E501

        :return: The invoicing_behavior of this SubscriptionRecordUpdateSerializerOldRequest.  # noqa: E501
        :rtype: str
        """
        return self._invoicing_behavior

    @invoicing_behavior.setter
    def invoicing_behavior(self, invoicing_behavior):
        """Sets the invoicing_behavior of this SubscriptionRecordUpdateSerializerOldRequest.

        The invoicing behavior to use when replacing the plan. Invoice now will invoice the customer for the prorated difference of the old plan and the new plan, whereas add_to_next_invoice will wait until the end of the subscription to do the calculation.  * `add_to_next_invoice` - Add to Next Invoice * `invoice_now` - Invoice Now  # noqa: E501

        :param invoicing_behavior: The invoicing_behavior of this SubscriptionRecordUpdateSerializerOldRequest.  # noqa: E501
        :type: str
        """
        allowed_values = ["add_to_next_invoice", "invoice_now"]  # noqa: E501
        if invoicing_behavior not in allowed_values:
            raise ValueError(
                "Invalid value for `invoicing_behavior` ({0}), must be one of {1}"  # noqa: E501
                .format(invoicing_behavior, allowed_values)
            )

        self._invoicing_behavior = invoicing_behavior

    @property
    def usage_behavior(self):
        """Gets the usage_behavior of this SubscriptionRecordUpdateSerializerOldRequest.  # noqa: E501

        The usage behavior to use when replacing the plan. Transfer to new subscription will transfer the usage from the old subscription to the new subscription, whereas keep_separate will reset the usage to 0 for the new subscription, while keeping the old usage on the old subscription and charging for that appropriately at the end of the month.  * `transfer_to_new_subscription` - Transfer to New Subscription * `keep_separate` - Keep Separate  # noqa: E501

        :return: The usage_behavior of this SubscriptionRecordUpdateSerializerOldRequest.  # noqa: E501
        :rtype: str
        """
        return self._usage_behavior

    @usage_behavior.setter
    def usage_behavior(self, usage_behavior):
        """Sets the usage_behavior of this SubscriptionRecordUpdateSerializerOldRequest.

        The usage behavior to use when replacing the plan. Transfer to new subscription will transfer the usage from the old subscription to the new subscription, whereas keep_separate will reset the usage to 0 for the new subscription, while keeping the old usage on the old subscription and charging for that appropriately at the end of the month.  * `transfer_to_new_subscription` - Transfer to New Subscription * `keep_separate` - Keep Separate  # noqa: E501

        :param usage_behavior: The usage_behavior of this SubscriptionRecordUpdateSerializerOldRequest.  # noqa: E501
        :type: str
        """
        allowed_values = ["transfer_to_new_subscription", "keep_separate"]  # noqa: E501
        if usage_behavior not in allowed_values:
            raise ValueError(
                "Invalid value for `usage_behavior` ({0}), must be one of {1}"  # noqa: E501
                .format(usage_behavior, allowed_values)
            )

        self._usage_behavior = usage_behavior

    @property
    def turn_off_auto_renew(self):
        """Gets the turn_off_auto_renew of this SubscriptionRecordUpdateSerializerOldRequest.  # noqa: E501

        Turn off auto renew for the subscription  # noqa: E501

        :return: The turn_off_auto_renew of this SubscriptionRecordUpdateSerializerOldRequest.  # noqa: E501
        :rtype: bool
        """
        return self._turn_off_auto_renew

    @turn_off_auto_renew.setter
    def turn_off_auto_renew(self, turn_off_auto_renew):
        """Sets the turn_off_auto_renew of this SubscriptionRecordUpdateSerializerOldRequest.

        Turn off auto renew for the subscription  # noqa: E501

        :param turn_off_auto_renew: The turn_off_auto_renew of this SubscriptionRecordUpdateSerializerOldRequest.  # noqa: E501
        :type: bool
        """

        self._turn_off_auto_renew = turn_off_auto_renew

    @property
    def end_date(self):
        """Gets the end_date of this SubscriptionRecordUpdateSerializerOldRequest.  # noqa: E501

        Change the end date for the subscription.  # noqa: E501

        :return: The end_date of this SubscriptionRecordUpdateSerializerOldRequest.  # noqa: E501
        :rtype: datetime
        """
        return self._end_date

    @end_date.setter
    def end_date(self, end_date):
        """Sets the end_date of this SubscriptionRecordUpdateSerializerOldRequest.

        Change the end date for the subscription.  # noqa: E501

        :param end_date: The end_date of this SubscriptionRecordUpdateSerializerOldRequest.  # noqa: E501
        :type: datetime
        """

        self._end_date = end_date

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(SubscriptionRecordUpdateSerializerOldRequest, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, SubscriptionRecordUpdateSerializerOldRequest):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
