try:
    import _utils as core
except ModuleNotFoundError:
    mnf = str(input("~| BASE IMPORT ERROR...\nThere was an error while gathering nebula.core\nPlease check that your installation directory contains the 'core' sub-directory.\nIf so, type 'fix' to open the Nebula Console.\nWhen the command line appears, type 'neb -fix ~core' to run the appropriate repair script.\nIf the problem persists, contact setoichi.\n~| "))
    if mnf in {"fix",}:
        print("open Abyss Console\n")
    import os
    os.sys.exit()


"""
NEBULA CORE OBJECTS
"""
class Physics:
    def __init__(self, game, cellSize=16):
        self.env = game
        self.tilemap = None
        self.cellSize = cellSize
        self.spatialPartitioning = {}
        self.isTopdown = game.isTopdown
        self.isPlatformer = game.isPlatformer

    def setTilemap(self, tilemap):
        self.tilemap = tilemap
        self.cellSize = tilemap.tileSize
        self.createSpatialPartitioning(tilemap)

    def addEntity(self, entity):
        self.insertEntity(entity)

    def removeEntity(self, entity):
        self.removeEntityFromGrid(entity)

    def createSpatialPartitioning(self, tilemap):
        self.spatialPartitioning = {}
        mapWidth = tilemap.mapSize.x
        mapHeight = tilemap.mapSize.y
        for x in range(0, int(mapWidth), self.cellSize):
            for y in range(0, int(mapHeight), self.cellSize):
                self.spatialPartitioning[f"{x};{y}"] = []

    def insertEntity(self, entity):
        entityCells = self.getCellsForEntity(entity)
        for cell in entityCells:
            self.spatialPartitioning[cell].append(entity)

    def removeEntityFromGrid(self, entity):
        entityCells = entity.spatialPartitioningCells
        for cell in entityCells:
            self.spatialPartitioning[cell].remove(entity)

    def getCellsForEntity(self, entity):
        entityRect = entity.rect()
        cells = set()
        left, top, right, bottom = entityRect.left, entityRect.top, entityRect.right, entityRect.bottom
        for x in range(left*self.cellSize, right*self.cellSize, self.cellSize):
            for y in range(top*self.cellSize, bottom*self.cellSize, self.cellSize):
                cells.add(f"{x};{y}")

        entity.spatialPartitioningCells = cells
        return entity.spatialPartitioningCells

    def update(self, dt):
        self.applyGravity(dt)
        self.handleEntityCollisions()

    def applyGravity(self, dt):
        for entity in self.env.entities:
            entity.velocity += core.pygame.core.pygame.math.Vector2(0, 16.8) * dt

    def handleEntityCollisions(self):
        for entity in self.env.entities:
            entityCells = entity.spatialPartitioningCells
            potentialColliders = set()
            for cell in entityCells:
                potentialColliders.update(self.spatialPartitioning[cell])
            for collider in potentialColliders:
                if entity.rect().colliderect(collider.rect()):
                    self.handleCollision(entity, collider)

    def handleCollision(self, entity, collider):
        if self.isPlatformer:
            if self.isCollidingFromAbove(entity, collider):
                entity.velocity.y = 0
                entity.position.y = collider.rect().bottom
            elif self.isCollidingFromBelow(entity, collider):
                entity.velocity.y = 0
                entity.position.y = collider.rect().top - entity.rectSize.y
            elif self.isCollidingFromLeft(entity, collider):
                entity.velocity.x = 0
                entity.position.x = collider.rect().right
            elif self.isCollidingFromRight(entity, collider):
                entity.velocity.x = 0
                entity.position.x = collider.rect().left - entity.rectSize.x
        elif self.isTopdown:
            pass

    def isCollidingFromAbove(self, entity, collider):
        return entity.rect().bottom > collider.rect().top and entity.rect().top < collider.rect().top

    def isCollidingFromBelow(self, entity, collider):
        return entity.rect().top < collider.rect().bottom and entity.rect().bottom > collider.rect().bottom

    def isCollidingFromLeft(self, entity, collider):
        return entity.rect().right > collider.rect().left and entity.rect().left < collider.rect().left

    def isCollidingFromRight(self, entity, collider):
        return entity.rect().left < collider.rect().right and entity.rect().right > collider.rect().right

    def updateSpatialPartitioning(self):
        for entity in self.env.entities:
            self.removeEntityFromGrid(entity)
            self.insertEntity(entity)


class Camera:
    def __init__(self, env, level_size, screen_size, camera_speed, scroll_interpolation):
        """A simple yet dynamic and flexible camera that produces and offset value simulating the movement of a camera existing within a space.

        Args:
            game (Game): a referance to the class containing your game loop
            level_size (pygame.math.Vector2): the dimensions of your game world as a vector
            display_size (pygame.math.Vector2): the dimensions of your game window as a vector
            camera_speed (int or float): the camera's speed in pps (pixels-per-second)
            scroll_interpolation (int or float): the interpolation value of the camera
        """
        self.env = env
        self.level_size = core.VECTOR2(level_size)
        self.screen_size = core.VECTOR2(screen_size)
        self.scroll = core.VECTOR2(0, 0)
        self.scroll_interpolation = scroll_interpolation
        self.scroll_speed = camera_speed
        self.DEADZONE_RADIUS = 10
        self.in_deadzone = False
        self.pan_speed = camera_speed/2
        self.panning = False
        self.pan_target = None

    def scrollCamera(self, target):
        desired_scroll = core.VECTOR2(
            target.rect().centerx - self.screen_size.x / 2,
            target.rect().centery - self.screen_size.y / 2
        )

        distance_to_target = (self.scroll - desired_scroll).length()
        if distance_to_target >= self.DEADZONE_RADIUS:
            self.scroll += (desired_scroll - self.scroll) * self.scroll_speed / self.scroll_interpolation * self.env.DT

    def panCamera(self, target):
        if type(target) == core.VECTOR2:
            desired_scroll = core.VECTOR2(
                target.x - self.screen_size.x / 2,
                target.y - self.screen_size.y / 2
            )
            # Use regular division for smoother interpolation
            self.scroll += (desired_scroll - self.scroll) * self.pan_speed / self.scroll_interpolation * self.env.DT
    
    def setTarget(self, target, screen_size, levelBound=False):
        self.screen_size = screen_size
        if not self.panning:
            self.scrollCamera(target)
        else:
            self.pan_target = target
            self.pan_camera(self.pan_target)

        if levelBound:
            # Constrain camera within the level bounds
            self.scroll.x = max(0, min(self.scroll.x, self.level_size.x - self.screen_size.x))
            self.scroll.y = max(0, min(self.scroll.y, self.level_size.y - self.screen_size.y))

    def getOffset(self):
        return core.VECTOR2(int(self.scroll.x), int(self.scroll.y))


class Entity(core.pygame.sprite.Sprite):
    def __init__(self, _id:int=core.random.randint(999,9999), position:core.pygame.math.Vector2()=core.pygame.math.Vector2(), size:int=32, rectSize=core.pygame.math.Vector2(32, 32), spriteGroups:list=[], color:list=[10, 30, 20]):
        super().__init__(spriteGroups)
        self._id = _id
        self.Renderer = None
        self.rectSize = rectSize
        self.size = core.pygame.math.Vector2(size, size)
        self.spriteGroups = spriteGroups
        self.position = core.pygame.math.Vector2(position)
        self.velocity = core.pygame.math.Vector2()
        self.image = core.pygame.Surface((size, size))
        self.image.fill(color)

    def rect(self):
        return core.pygame.Rect((self.position.x, self.position.y), (self.rectSize[0], self.rectSize[1]))

    def setRenderer(self, renderer):
        self.Renderer = renderer

    def update(self):
        self.collisions = {"up": False, "down": False, "left": False, "right": False}
        self.position += self.velocity


class NebulaCache:
    def __init__(self, maxSize=100):
        self.cache = {"base": {"cache": {}, "frequency": {}}}
        self.usage = []
        self.maxSize = maxSize

    def get(self, key, subCache=None):
        subCache = subCache if subCache in self.cache else "base"
        cache = self.cache[subCache]["cache"]
        frequency = self.cache[subCache]["frequency"]

        if key in cache:
            frequency[key] += 1
            self.updateUsage(key, subCache)
            return cache[key]
        else:
            return 'Key Not Present'

    def put(self, key, value, subCache=None):
        if self.maxSize <= 0:
            return 'Cache is disabled'

        if subCache in self.cache:
            cache = self.cache[subCache]["cache"]
            frequency = self.cache[subCache]["frequency"]
        elif subCache not in self.cache:
            self.cache[subCache] = {"cache":{}, "frequency":{}}
            cache = self.cache[subCache]["cache"]
            frequency = self.cache[subCache]["frequency"]

        if self.checkSize(subCache) >= self.maxSize:
            minFrequencyKey = min(frequency, key=lambda k: (frequency[k], self.usage.index(k)))
            del cache[minFrequencyKey]
            del frequency[minFrequencyKey]

        try:
            cache[key] = value
            frequency[key] = 1
            self.updateUsage(key, subCache)
        except (KeyError, ValueError):
            return 'Key or Value was not given'

    def checkSize(self, subCache="base"):
        return len(self.cache[subCache]["cache"])

    def updateUsage(self, key, subCache="base"):
        if key in self.usage:
            self.usage.remove(key)
        self.usage.append(key)


class Animation:
    def __init__(self, images, frameCount=5, loop=True):
        self.images = images
        self.imageMasks = [core.pygame.mask.from_surface(image) for image in images]
        self.loop = loop
        self.frameCount = frameCount
        self.done = False
        self.frame = 0

    def copy(self):
        return Animation(self.images, self.frameCount, self.loop)

    def update(self):
        if not self.done:
            self.frame = (self.frame + 1) % (self.frameCount * len(self.images)) if self.loop else min(self.frame + 1, self.frameCount * len(self.images) - 1)

    def img(self):
        frameIndex = int(self.frame / self.frameCount)
        return [self.images[frameIndex], self.imageMasks]


class AssetManager:
    def __init__(self, env, maxCacheSize=100):
        self._env = env
        self.cache = NebulaCache(maxSize=maxCacheSize)

    def loadLiveAssets(self, assetsPath: str, animationLib: dict, frameCount: int, willLoop: bool, subCache=None):
        loadedAssets = {}
        for key, folderPath in animationLib.items():
            self.cache.put(key=key, value=Animation(core.loadAssetDir(assetsPath + f"{folderPath}"), frameCount=frameCount, loop=willLoop), subCache=subCache)
        return True

    def loadStaticAsset(self, assetName: str, assetPath: str, subCache=None):
        self.cache.put(key=assetName, value=core.loadAsset(assetPath))
        return True

    def putAsset(self, assetID, asset, subCache=None):
        self.cache.put(assetID, asset, subCache=subCache)

    def getAssetByID(self, assetID, subCache=None):
        return self.cache.get(assetID, subCache=subCache)

    def reloadAssetPosition(self, assetID, position, subCache=None):
    
        asset = self.getAssetByID(assetID)
        if asset:
            self._env.Renderer.addStaticRenderData(assetID, position)
        else:
            return f"Asset not found: {assetID}"


class Renderer:
    def __init__(self, env, display:core.pygame.Surface, layerCount: int, assetManager: AssetManager, canvas:core.pygame.Surface=None):
        self.display = display
        if canvas != None:
            self.canvas = canvas
        self.layerCount = layerCount
        self.renderLayers = [[] for _ in range(layerCount)]
        self.dirtyRects = []
        self.assetManager = assetManager
        self.renderData = []
        self.camera = env.Camera

    def addStaticRenderData(self, assetID: str|int, position: core.pygame.math.Vector2(0, 0)=core.pygame.math.Vector2(0, 0), offset: core.pygame.math.Vector2(0, 0)=core.pygame.math.Vector2(0, 0)):
        self.renderData.append((assetID, position, offset))
    
    def addLayer(self):
        self.layerCount += 1
        self.renderLayers.append([])

    def addAsset(self, assetID: str|int, asset: core.pygame.Surface, layerNumber: int=0):
        self.renderLayers[layerNumber].append(asset)
        self.dirtyRects.append(asset.get_rect())

    def addEntity(self, obj: Entity, layerNumber: int=0):
        self.renderLayers[layerNumber].append(obj)
        self.assetManager.putAsset(obj._id, obj, subCache="Entities")
        self.dirtyRects.append(
            core.pygame.Rect(
                obj.position - self.camera.getOffset(),
                obj.rect().size
            )
        )
        # self.dirtyRects.append(obj.rect())

    def render(self):
        try:
            self.canvas.fill((0, 0, 0)) 
        except AttributeError:
            self.display.fill((0, 0, 0)) 
        
        for layer in self.renderLayers:
            for item in layer:
                if isinstance(item, Entity):
                    try:
                        self.canvas.blit(item.image, (item.rect().x-self.camera.getOffset().x, item.rect().y-self.camera.getOffset().y))
                    except AttributeError:
                        self.display.blit(item.image, (item.rect().x-self.camera.getOffset().x, item.rect().y-self.camera.getOffset().y))
                        core.pygame.draw.rect(self.display, [0,255,0], item.rect())
                        print('rendering here')
                elif isinstance(item, core.pygame.Surface):
                    try:
                        self.canvas.blit(item, item.get_rect()-self.camera.getOffset())
                    except AttributeError:
                        self.display.blit(item, item.get_rect()-self.camera.getOffset())
                else:
                    return f"Unsupported item in render layer: {item}"

        

    def clearDirtyRects(self):
        self.dirtyRects.clear()


class Tilemap:
    def __init__(self, mapDataPath, game, renderer, tileSize=32, physicsTilesIds=None):
        self.env = game
        self.Renderer = renderer
        self.AssetManager = self.Renderer.assetManager
        self.cache = self.AssetManager.cache
        self.tileSize = tileSize
        self.tilemap = {}
        self.physicsTileIDs = set(physicsTilesIds) if physicsTilesIds else set()
        self.load(mapDataPath)

    def load(self, path):
        with open(path, "r") as savefile:
            map_data = core.json.load(savefile)

        self.mapName = map_data["name"]
        self.tilemap = map_data["tileMap"]
        self.tileSize = map_data["tileSize"]
        self.offgrid_tiles = map_data["offGrid"]
        self.mapSize = core.pygame.math.Vector2(map_data['width']*self.tileSize, map_data['height']*self.tileSize)

        try:
            [self.AssetManager.putAsset(_id, tile, subCache="tiles") for _id, tile in enumerate(core.cLoadAssets(map_data["tilesetPath"], self.tileSize))]
        except (KeyError, ValueError):
            return 'unable to cache tileset\n'

    def getMapSize(self, in_tiles=True):
        return self.mapSize.x, self.mapSize.y

    def solidTileCheck(self, position, layer):
        tileLocation = f"{int(position[0] // self.tileSize)};{int(position[1] // self.tileSize)}"
        if layer in self.tilemap and tileLocation in self.tilemap[layer]:
            tile = self.tilemap[layer][tileLocation]
            if tile['id'] in self.physicsTileIDs:
                return tile

    def extractTileInfo(self, tileId, keep=False):
        matches = []
        for layer in self.tilemap.values():
            for location, tile in list(layer.items()):
                if tile['id'] in tileId:
                    matches.append(tile.copy())
                    if not keep:
                        del layer[location]
        
        return matches

    def tilesAround(self, position, layer):
        tiles = []
        tileLocation = (int(position[0] // self.tileSize), int(position[1] // self.tileSize))

        for offset in [(i, j) for i in [-1, 0, 1] for j in [-1, 0, 1]]:
            checkLocation = f"{tileLocation[0] + offset[0]};{tileLocation[1] + offset[1]}"
            if layer in self.tilemap and checkLocation in self.tilemap[layer]:
                tiles.append(self.tilemap[layer][checkLocation])
        
        return tiles

    def physicsRectsAround(self, position, layer):
        rects = []

        for tile in self.tilesAround(position, layer):
            if tile['id'] in self.physicsTileIDs:
                tileX, tileY = tile['position']
                rect = core.pygame.Rect(tileX * self.tileSize, tileY * self.tileSize, self.tileSize, self.tileSize)
                rects.append(rect)
        
        return rects

    def exportAsPng(self, savePath):
        mapSize = self.getMapSize(inTiles=False)
        exportSurface = core.pygame.Surface(mapSize)
        exportSurface.fill((255, 255, 255))

        for layer in self.tilemap.values():
            for location, tile in list(layer.items()):
                tileImage = self.cache.cache['tiles']['cache'][tile['id']]
                x, y = tile['position']
                position = (x * self.tileSize, y * self.tileSize)
                exportSurface.blit(tileImage, position)

        exportFilename = f'{self.mapName}.png'
        fullExportPath = core.os.path.join(savePath, exportFilename)
        core.pygame.image.save(exportSurface, fullExportPath)
        return f"Map exported as {fullExportPath}"

    def render(self, surface, offset=core.pygame.math.Vector2(), zoomFactor=1):
        visibleArea = core.pygame.Rect(1 / zoomFactor, 1 / zoomFactor, surface.get_width(), surface.get_height())
        for layer in self.tilemap.values():
            for location, tile in list(layer.items()):
                tileRect = core.pygame.Rect(
                    tile['position'][0] * self.tileSize - offset[0],
                    tile['position'][1] * self.tileSize - offset[1],
                    self.tileSize, self.tileSize
                )

                if tileRect.colliderect(visibleArea):
                    assetId = tile['id']
                    asset = self.cache.cache['tiles']['cache'][assetId]
                    position = core.pygame.math.Vector2(tileRect.topleft)
                    self.Renderer.renderAssets([assetId], surface, [position])
                
