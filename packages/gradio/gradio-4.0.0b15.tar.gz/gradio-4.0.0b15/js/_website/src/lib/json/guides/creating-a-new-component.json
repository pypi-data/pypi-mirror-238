{"guide": {"name": "creating-a-new-component", "category": "other-tutorials", "pretty_category": "Other Tutorials", "guide_index": null, "absolute_index": 36, "pretty_name": "Creating A New Component", "content": "# How to Create a New Component\n\n## Introduction\n\nThe purpose of this guide is to illustrate how to add a new component, which you can use in your Gradio applications. The guide will be complemented by code snippets showing step by step how the [ColorPicker](https://gradio.app/docs/#colorpicker) component was added.\n\n## Prerequisites\n\nMake sure you have followed the [CONTRIBUTING.md](https://github.com/gradio-app/gradio/blob/main/CONTRIBUTING.md) guide in order to setup your local development environment (both client and server side).\n\nHere's how to create a new component on Gradio:\n\n1. [Create a New Python Class and Import it](#1-create-a-new-python-class-and-import-it)\n2. [Create a New Svelte Component](#2-create-a-new-svelte-component)\n3. [Create a New Demo](#3-create-a-new-demo)\n\n## 1. Create a New Python Class and Import it\n\nThe first thing to do is to create a new class within the [components.py](https://github.com/gradio-app/gradio/blob/main/gradio/components.py) file. This Python class should inherit from a list of base components and should be placed within the file in the correct section with respect to the type of component you want to add (e.g. input, output or static components).\nIn general, it is advisable to take an existing component as a reference (e.g. [TextBox](https://github.com/gradio-app/gradio/blob/main/gradio/components.py#L290)), copy its code as a skeleton and then adapt it to the case at hand.\n\nLet's take a look at the class added to the [components.py](https://github.com/gradio-app/gradio/blob/main/gradio/components.py) file for the ColorPicker component:\n\n```python\n@document()\nclass ColorPicker(Changeable, Submittable, IOComponent):\n    \"\"\"\n    Creates a color picker for user to select a color as string input.\n    Preprocessing: passes selected color value as a {str} into the function.\n    Postprocessing: expects a {str} returned from function and sets color picker value to it.\n    Examples-format: a {str} with a hexadecimal representation of a color, e.g. \"#ff0000\" for red.\n    Demos: color_picker, color_generator\n    \"\"\"\n\n    def __init__(\n        self,\n        value: str = None,\n        *,\n        label: Optional[str] = None,\n        show_label: bool = True,\n        interactive: Optional[bool] = None,\n        visible: bool = True,\n        elem_id: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Parameters:\n            value: default text to provide in color picker.\n            label: component name in interface.\n            show_label: if True, will display label.\n            interactive: if True, will be rendered as an editable color picker; if False, editing will be disabled. If not provided, this is inferred based on whether the component is used as an input or output.\n            visible: If False, component will be hidden.\n            elem_id: An optional string that is assigned as the id of this component in the HTML DOM. Can be used for targeting CSS styles.\n        \"\"\"\n        self.value = self.postprocess(value)\n        self.cleared_value = \"#000000\"\n        self.test_input = value\n        IOComponent.__init__(\n            self,\n            label=label,\n            show_label=show_label,\n            interactive=interactive,\n            visible=visible,\n            elem_id=elem_id,\n            **kwargs,\n        )\n\n    def get_config(self):\n        return {\n            \"value\": self.value,\n            **IOComponent.get_config(self),\n        }\n\n    @staticmethod\n    def update(\n        value: Optional[Any] = None,\n        label: Optional[str] = None,\n        show_label: Optional[bool] = None,\n        visible: Optional[bool] = None,\n        interactive: Optional[bool] = None,\n    ):\n        return {\n            \"value\": value,\n            \"label\": label,\n            \"show_label\": show_label,\n            \"visible\": visible,\n            \"interactive\": interactive,\n            \"__type__\": \"update\",\n        }\n\n    # Input Functionalities\n    def preprocess(self, x: str | None) -> Any:\n        \"\"\"\n        Any preprocessing needed to be performed on function input.\n        Parameters:\n        x (str): text\n        Returns:\n        (str): text\n        \"\"\"\n        if x is None:\n            return None\n        else:\n            return str(x)\n\n    def preprocess_example(self, x: str | None) -> Any:\n        \"\"\"\n        Any preprocessing needed to be performed on an example before being passed to the main function.\n        \"\"\"\n        if x is None:\n            return None\n        else:\n            return str(x)\n\n    # Output Functionalities\n    def postprocess(self, y: str | None):\n        \"\"\"\n        Any postprocessing needed to be performed on function output.\n        Parameters:\n        y (str | None): text\n        Returns:\n        (str | None): text\n        \"\"\"\n        if y is None:\n            return None\n        else:\n            return str(y)\n\n    def deserialize(self, x):\n        \"\"\"\n        Convert from serialized output (e.g. base64 representation) from a call() to the interface to a human-readable version of the output (path of an image, etc.)\n        \"\"\"\n        return x\n```\n\nOnce defined, it is necessary to import the new class inside the [\\_\\_init\\_\\_](https://github.com/gradio-app/gradio/blob/main/gradio/__init__.py) module class in order to make it module visible.\n\n```python\n\nfrom gradio.components import (\n    ...\n    ColorPicker,\n    ...\n)\n\n```\n\n### 1.1 Writing Unit Test for Python Class\n\nWhen developing new components, you should also write a suite of unit tests for it. The tests should be placed in the [gradio/test/test_components.py](https://github.com/gradio-app/gradio/blob/main/test/test_components.py) file. Again, as above, take a cue from the tests of other components (e.g. [Textbox](https://github.com/gradio-app/gradio/blob/main/test/test_components.py)) and add as many unit tests as you think are appropriate to test all the different aspects and functionalities of the new component. For example, the following tests were added for the ColorPicker component:\n\n```python\nclass TestColorPicker(unittest.TestCase):\n    def test_component_functions(self):\n        \"\"\"\n        Preprocess, postprocess, serialize, save_flagged, restore_flagged, tokenize, get_config\n        \"\"\"\n        color_picker_input = gr.ColorPicker()\n        self.assertEqual(color_picker_input.preprocess(\"#000000\"), \"#000000\")\n        self.assertEqual(color_picker_input.preprocess_example(\"#000000\"), \"#000000\")\n        self.assertEqual(color_picker_input.postprocess(None), None)\n        self.assertEqual(color_picker_input.postprocess(\"#FFFFFF\"), \"#FFFFFF\")\n        self.assertEqual(color_picker_input.serialize(\"#000000\", True), \"#000000\")\n\n        color_picker_input.interpretation_replacement = \"unknown\"\n\n        self.assertEqual(\n            color_picker_input.get_config(),\n            {\n                \"value\": None,\n                \"show_label\": True,\n                \"label\": None,\n                \"style\": {},\n                \"elem_id\": None,\n                \"visible\": True,\n                \"interactive\": None,\n                \"name\": \"colorpicker\",\n            },\n        )\n\n    def test_in_interface_as_input(self):\n        \"\"\"\n        Interface, process, interpret,\n        \"\"\"\n        iface = gr.Interface(lambda x: x, \"colorpicker\", \"colorpicker\")\n        self.assertEqual(iface.process([\"#000000\"]), [\"#000000\"])\n\n    def test_in_interface_as_output(self):\n        \"\"\"\n        Interface, process\n\n        \"\"\"\n        iface = gr.Interface(lambda x: x, \"colorpicker\", gr.ColorPicker())\n        self.assertEqual(iface.process([\"#000000\"]), [\"#000000\"])\n\n    def test_static(self):\n        \"\"\"\n        postprocess\n        \"\"\"\n        component = gr.ColorPicker(\"#000000\")\n        self.assertEqual(component.get_config().get(\"value\"), \"#000000\")\n```\n\n## 2. Create a New Svelte Component\n\nLet's see the steps you need to follow to create the frontend of your new component and to map it to its python code:\n\n- Create a new UI-side Svelte component and figure out where to place it. The options are: create a package for the new component in the [js folder](https://github.com/gradio-app/gradio/tree/main/js/), if this is completely different from existing components or add the new component to an existing package, such as to the [form package](https://github.com/gradio-app/gradio/tree/main/js/form). The ColorPicker component for example, was included in the form package because it is similar to components that already exist.\n- Create a file with an appropriate name in the src folder of the package where you placed the Svelte component, note: the name must start with a capital letter. This is the 'core' component and it's the generic component that has no knowledge of Gradio specific functionality. Initially add any text/html to this file so that the component renders something. The Svelte application code for the ColorPicker looks like this:\n\n```typescript\n<script lang=\"ts\">\n\timport { createEventDispatcher } from \"svelte\";\n\timport { get_styles } from \"@gradio/utils\";\n\timport { BlockTitle } from \"@gradio/atoms\";\n\timport type { Styles } from \"@gradio/utils\";\n\n\texport let value: string = \"#000000\";\n\texport let style: Styles = {};\n\texport let label: string;\n\texport let disabled = false;\n\texport let show_label: boolean = true;\n\n\t$: value;\n\t$: handle_change(value);\n\n\tconst dispatch = createEventDispatcher<{\n\t\tchange: string;\n\t\tsubmit: undefined;\n\t}>();\n\n\tfunction handle_change(val: string) {\n\t\tdispatch(\"change\", val);\n\t}\n\n\t$: ({ styles } = get_styles(style, [\"rounded\", \"border\"]));\n</script>\n\n<!-- svelte-ignore a11y-label-has-associated-control -->\n<label class=\"block\">\n\t<BlockTitle {show_label}>{label}</BlockTitle>\n\t<input\n\t\ttype=\"color\"\n\t\tclass=\"gr-box-unrounded {classes}\"\n\t\tbind:value\n\t\t{disabled}\n\t/>\n</label>\n```\n\n- Export this file inside the index.ts file of the package where you placed the Svelte component by doing `export { default as FileName } from \"./FileName.svelte\"`. The ColorPicker file is exported in the [index.ts](https://github.com/gradio-app/gradio/blob/main/js/form/src/index.ts) file and the export is performed by doing: `export { default as ColorPicker } from \"./ColorPicker.svelte\";`.\n- Create the Gradio specific component in [js/app/src/components](https://github.com/gradio-app/gradio/tree/main/js/app/src/components). This is a Gradio wrapper that handles the specific logic of the library, passes the necessary data down to the core component and attaches any necessary event listeners. Copy the folder of another component, rename it and edit the code inside it, keeping the structure.\n\nHere you will have three files, the first file is for the Svelte application, and it will look like this:\n\n```typescript\n<svelte:options accessors={true} />\n\n<script lang=\"ts\">\n\timport { ColorPicker } from \"@gradio/form\";\n\timport { Block } from \"@gradio/atoms\";\n\timport StatusTracker from \"@gradio/statustracker\";\n\timport type { LoadingStatus } from \"@gradio/statustracker/types\";\n\timport type { Styles } from \"@gradio/utils\";\n\n\texport let label: string = \"ColorPicker\";\n\texport let elem_id: string = \"\";\n\texport let visible: boolean = true;\n\texport let value: string;\n\texport let form_position: \"first\" | \"last\" | \"mid\" | \"single\" = \"single\";\n\texport let show_label: boolean;\n\n\texport let style: Styles = {};\n\n\texport let loading_status: LoadingStatus;\n\n\texport let interactive: boolean;\n</script>\n\n<Block\n\t{visible}\n\t{form_position}\n\t{elem_id}\n\tdisable={typeof style.container === \"boolean\" && !style.container}\n>\n\t<StatusTracker {...loading_status} />\n\n\t<ColorPicker\n\t\t{style}\n\t\tbind:value\n\t\t{label}\n\t\t{show_label}\n\t\ton:change\n\t\ton:submit\n\t\tdisabled={!interactive}\n\t/>\n</Block>\n```\n\nThe second one contains the tests for the frontend, for example for the ColorPicker component:\n\n```typescript\nimport { test, describe, assert, afterEach } from \"vitest\";\nimport { cleanup, render } from \"@gradio/tootils\";\n\nimport ColorPicker from \"./ColorPicker.svelte\";\nimport type { LoadingStatus } from \"@gradio/statustracker/types\";\n\nconst loading_status = {\n\teta: 0,\n\tqueue_position: 1,\n\tstatus: \"complete\" as LoadingStatus[\"status\"],\n\tscroll_to_output: false,\n\tvisible: true,\n\tfn_index: 0\n};\n\ndescribe(\"ColorPicker\", () => {\n\tafterEach(() => cleanup());\n\n\ttest(\"renders provided value\", () => {\n\t\tconst { getByDisplayValue } = render(ColorPicker, {\n\t\t\tloading_status,\n\t\t\tshow_label: true,\n\t\t\tinteractive: true,\n\t\t\tvalue: \"#000000\",\n\t\t\tlabel: \"ColorPicker\"\n\t\t});\n\n\t\tconst item: HTMLInputElement = getByDisplayValue(\"#000000\");\n\t\tassert.equal(item.value, \"#000000\");\n\t});\n\n\ttest(\"changing the color should update the value\", async () => {\n\t\tconst { component, getByDisplayValue } = render(ColorPicker, {\n\t\t\tloading_status,\n\t\t\tshow_label: true,\n\t\t\tinteractive: true,\n\t\t\tvalue: \"#000000\",\n\t\t\tlabel: \"ColorPicker\"\n\t\t});\n\n\t\tconst item: HTMLInputElement = getByDisplayValue(\"#000000\");\n\n\t\tassert.equal(item.value, \"#000000\");\n\n\t\tawait component.$set({\n\t\t\tvalue: \"#FFFFFF\"\n\t\t});\n\n\t\tassert.equal(component.value, \"#FFFFFF\");\n\t});\n});\n```\n\nThe third one is the index.ts file:\n\n```typescript\nexport { default as Component } from \"./ColorPicker.svelte\";\nexport const modes = [\"static\", \"dynamic\"];\n```\n\n- Add the mapping for your component in the [directory.ts file](https://github.com/gradio-app/gradio/blob/main/js/app/src/components/directory.ts). To do this, copy and paste the mapping line of any component and edit its text. The key name must be the lowercase version of the actual component name in the Python library. So for example, for the ColorPicker component the mapping looks like this:\n\n```typescript\nexport const component_map = {\n...\ncolorpicker: () => import(\"./ColorPicker\"),\n...\n}\n```\n\n### 2.1 Writing Unit Test for Svelte Component\n\nWhen developing new components, you should also write a suite of unit tests for it. The tests should be placed in the new component's folder in a file named MyAwesomeComponent.test.ts. Again, as above, take a cue from the tests of other components (e.g. [Textbox.test.ts](https://github.com/gradio-app/gradio/blob/main/js/app/src/components/Textbox/Textbox.test.ts)) and add as many unit tests as you think are appropriate to test all the different aspects and functionalities of the new component.\n\n### 3. Create a New Demo\n\nThe last step is to create a demo in the [gradio/demo folder](https://github.com/gradio-app/gradio/tree/main/demo), which will use the newly added component. Again, the suggestion is to reference an existing demo. Write the code for the demo in a file called run.py, add the necessary requirements and an image showing the application interface. Finally add a gif showing its usage.\nYou can take a look at the [demo](https://github.com/gradio-app/gradio/tree/main/demo/color_picker) created for the ColorPicker, where an icon and a color selected through the new component is taken as input, and the same icon colored with the selected color is returned as output.\n\nTo test the application:\n\n- run on a terminal `python path/demo/run.py` which starts the backend at the address [http://localhost:7860](http://localhost:7860);\n- in another terminal, run `pnpm dev` to start the frontend at [http://localhost:9876](http://localhost:9876) with hot reload functionalities.\n\n## Conclusion\n\nIn this guide, we have shown how simple it is to add a new component to Gradio, seeing step by step how the ColorPicker component was added. For further details, you can refer to PR: [#1695](https://github.com/gradio-app/gradio/pull/1695).\n", "tags": [], "spaces": [], "url": "/guides/creating-a-new-component/", "contributor": null}}