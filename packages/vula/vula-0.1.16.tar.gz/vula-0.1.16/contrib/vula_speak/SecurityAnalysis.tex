\documentclass[a4paper,11pt]{report}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{hyperref}
\hypersetup{pdfborder=0 0 0}


\title{Security Analysis of the Vula speak project}
\author{Jens Hubler, Lukas Moser, Robin Renker, Simon WÃ¤lchli}

\begin{document}

\maketitle
\tableofcontents

\chapter{Introduction}
Vula automatically discovers peers over untrusted local networks. The Vula speak project uses audio as an out of band verification method for previously discovered Vula peers.
Using sound as an alternative verification process adds new attack vectors to the scope of the Vula project. This document provides information about the new features and a security analysis of the new attack surface. Where possible, we mitigate the attack surface while implementing the new features. 

\chapter{General considerations}
The Vula speak project requires encoding data and transmitting it as audio. The Vula project also requires a corresponding decoding of audio data. Vula speak requires adding two libraries, pyaudio and ggwave, we consider these libraries in the following subsections
\section{Dependencies}
\subsection{pyaudio}
pyaudio\footnote[0]{https://people.csail.mit.edu/hubert/pyaudio/} is a library which enables python programs to interface with a microphone or audio input device, and an audio output device. \texttt{pyaudio} requires permissions for accessing these two devices. For transmission it requires encoded audio data, for receiving it requires a corresponding library to decode audio data. We find that \texttt{pyaudio} is well supported and a mature library with minimal attack surface as it does not encode or decode audio data, it merely reads and writes bytes form the audio device.
\subsection{ggwave}
\texttt{ggwave}\footnote[1]{https://github.com/ggerganov/ggwave} is a library which enables the system to communicate small amounts of data between air-gapped devices using the sound device. \texttt{ggwave} encodes data as a wave form for use with a corresponding audio library that opens a sound device. \texttt{ggwave} implements a simple FSK-based transmission protocol. The library is used to generate and to analyze the RAW waveforms that are played and captured from the audio device.\newline
\texttt{ggwave} is written in C++ with automatic python bindings generated by \texttt{cython}. This language boundary presents an attack surface, as does the library itself. We examined the \texttt{ggwave} library and the python bindings with valgrind. See Section~\ref{valgrind} for our analysis of \texttt{ggwave} using Valgrind.

\subsection{Licensing}
The \texttt{ggwave} and \texttt{pyaudio} projects are licensed under the MIT License (also called "Expat License") and with that have very limited restrictions on reuse.
According to the GNU project (\url{https://www.gnu.org/licenses/license-list.html}) the MIT License (Expat License) is compatible with the GNU General Public License (GNU GPL) that the Vula project is licensed under. \newline
That means we are able to freely use the \texttt{ggwave} and \texttt{pyaudio} library for our project.

\subsection{Packaging considerations}
The Vula dependencies are updated to require two new packages python3-pyaudio and portaudio19-dev. Unfortunately \texttt{ggwave} is not packaged in Debian or Ubuntu, it must be installed through an alternate process.



\chapter{Vula speak security considerations}
Vula speak sends a cryptographic hash of the latest peer descriptor over an out-of-band audio channel to confirm that the peer's latest descriptor is indeed the same on both sides and correctly associated with a given hostname.
\section{Threat model}
The purpose of Vula speak is to verify out of band and already discovered Vula peers. We presume that the network may have hostile adversaries and we wish to verify out of band that the discovered key matches for a given hostname. We presume that two users doing an acoustical verification will notice if another computer begins to transmit at the same time, thus Vula speak is a convenience protocol similar to the QR code verification process. We assume an adversary may record the audio of a room and thus confirm that a verification has taken place. Similarly we assume that an adversary may record Vula descriptors broadcast on a local network.
The primary purpose of Vula speak is thus to simplify the verification of specific peers.

\subsection{Considered attack vectors}
Vula itself only provides protection against active adversaries if peers are verified. Thus Vula speak attempts to ease verification of peers. We consider attacks on the verification process:
\begin{enumerate}
  \item Record sound data to get access to a device's verification key
  \item An adversary attempts to send a hash of their verification key during a verification
  \item An adversary transmits a hostile audio message that exploits the audio processing library
\end{enumerate}
To mitigate attacks on Vula peers who are unverified, we attempt to ease the verification process. Out of band verification requires an adversary to mount an acoustical attack in addition to broadcasting new Vula descriptors. The attack must be carried out while a peer has manually enabled the acoustic verification process for a given specified hostname.
We assume that an adversary will record sound data and presume that if they are also recording network data, they can confirm that a given peer has verified or attempted to verify using Vula speak. Adversaries can confirm guesses by doing an audio recording of the verification process and hashing a given verification key to check if it matches the recorded audio.
\\[4mm]
The first attack vector is problematic because it's possible for an attacker to get information about the network (verification key of a device) without actually being in the network. If a new device is added to the network and the users want to verify each other's devices, the adversary will be able to learn about their keys.
\\[4mm]
The second attack vector is difficult to mitigate except that the attacker gets one shot for a specific hostname. They must be synchronised with the verification process. We presume that users will notice if a third computer begins to play audio as two users begin a verification process.
The third attack vector requires that the adversary finds a vulnerability in either \texttt{pyaudio} or \texttt{ggwave}. We believe that it is possible that both of these libraries have security vulnerabilities. We found a memory management issue in \texttt{ggwave} immediately, though we did not attempt to exploit it. There may be additional security vulnerabilities. It is for this reason and other privacy concerns, that we do not have constant audio processing but require a manual command that takes a hostname and only runs for a fixed amount of time.
More problematic is the second attack vector where the attacker can inject data after having injected the adversaries vk into the network. The attacker would then attempt to trick the users into verification of a vk that belongs to the adversary rather than the correct peer.
Sound injection can also be used to cause buffer overflows or maybe even inject some kind of commands. Thus an attacker might take control of a machine by playing a specific audio file.
While analyzing the \texttt{ggwave} library with valgrind we found a memory leak in the Python binding. That issue is now resolved in \texttt{ggwave} version 0.4.2.  We did not perform a comprehensive code review of ggwave and we consider this to be future work.
\subsection{Attack mitigations}
First we do not broadcast public keys directly but rather hashed public keys as it is impossible to know who or what is listening. We hash to prevent attackers from acquiring data about the device that's being verified. If the attacker already has access to some or all verification keys for the devices in the network, it would still be possible to brute force the hashes and check which verification keys were transmitted.
We considered an additional option to add a salt to the hashing process but we found that this would provide very little benefit. It complicates the process for very little benefit and the users must communicate that salt value somehow such as by speaking.
\subsubsection{Library security considerations}
We recompiled python with support for valgrind and analysed ggwave.
\paragraph*{Valgrind analysis:}\label{valgrind}
In order to test \texttt{ggwave} for possible memory leaks, we recompiled python with support for "Valgrind-Mode" and disabling pymalloc.
Tests are split up into four steps:
\begin{tabbing}
1. Step: Download python: \\
~~~~ \= Download python according to installed version (In our case 3.9.2)  \\
2. Step: Compile python with new settings \\
\> ./configure --prefix=/path/to/python/check\_ggwave/python/ --without-pymalloc --with-pydebug --with-valgrind \\
\> make OPT=-g \\
\> make install \\
3. Step: Create venv based on new python version \\
\> python3 -m venv .venv \\
\> . .venv/bin/activate \\
\> pip3 install ggwave \\
4. Step: Run valgrind on test-ggwave.pyaudio \\
\> Download \url{https://github.com/ggerganov/ggwave/blob/master/tests/test-ggwave.py} \\
\> valgrind --leak-check=full --log-file="valgrind\_report.txt" python test-ggwave.py
\end{tabbing}
The full report can be found in this repo: \path{/contrib/vula_speak/valgrind_report_test_ggwave_python.txt}  \\
This will provide a quick summary:

\begin{verbatim}
==18560== LEAK SUMMARY:
==18560==    definitely lost: 1,800 bytes in 9 blocks
==18560==    indirectly lost: 568 bytes in 6 blocks
==18560==      possibly lost: 790,082 bytes in 6,445 blocks
==18560==    still reachable: 84,547 bytes in 18 blocks
==18560==         suppressed: 48 bytes in 1 blocks
\end{verbatim}

To compare the results we also run a C++ implementation of \texttt{ggwave} against valgrind. This test resulted in no memory leak which means there might be a problem \newline
in regard to the python bindings. The following list will provide a quick summary, for more details check: \path{/contrib/vula_speak/valgrind_test_ggwave_cpp.txt}
\begin{verbatim}
  ==7770== LEAK SUMMARY:
  ==7770==    definitely lost: 0 bytes in 0 blocks
  ==7770==    indirectly lost: 0 bytes in 0 blocks
  ==7770==      possibly lost: 0 bytes in 0 blocks
  ==7770==    still reachable: 22,013,520 bytes in 17 blocks
  ==7770==         suppressed: 0 bytes in 0 blocks
  \end{verbatim}

\paragraph*{Indepth problem analysis:}
In order to determine where the leaks are coming from we then executed valgrind using python and a \texttt{ggwave} implementation which only listens and another one which speaks.
Both results can be checked in the following files:
\\
\path{/contrib/vula_speak/valgrind_python_listen.txt}
\\
\path{/contrib/vula_speak/valgrind_python_speak.txt}
\\
No additional information was gained by this test as both implementations led to memory leaks.

\paragraph*{Conclusion:} We discovered a problem with the Python bindings (translation from C++ to Python) which leads to a memory leak. The bindings are created by cython by generating Python module bindings from the C++ \texttt{ggwave} library. The author of \texttt{ggwave} has confirmed this in our bug report\footnote[2]{https://github.com/ggerganov/ggwave/issues/81} and a fix has been shipped in version 0.4.2.

\paragraph*{Future Work:}
To further improve the security aspect of this feature, an in depth audit on the libraries \texttt{pyaudio}, and \texttt{ggwave} could be done.
\\
Concerning the functionality, an automated calibration feature could guide the user to adjust the speaker and microphone or even tell a user to move the devices physically closer together.
\\
The feature itself could also be modified to automatically acknowledge a received verification key such that a client sending the hashed verification key gets a confirmation that it has been received. And resend the hashed verification key until an acknowledgment has been received.
\\
The functionality of transmitting data over sound, provided by \texttt{ggwave}, could also be implemented in other features such as an alternative discovery mechanism.

\end{document}
