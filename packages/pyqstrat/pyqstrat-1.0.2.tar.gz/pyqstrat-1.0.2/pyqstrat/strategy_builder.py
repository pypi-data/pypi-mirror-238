# $$_ Lines starting with # $$_* autogenerated by jup_mini. Do not modify these
# $$_markdown
# # Strategy Builder
# 
# ## Purpose
# Makes it easier to build simpler strategies by removing the need for a lot of boilerplate code
# $$_end_markdown
# $$_code
# $$_ %%checkall
import numpy as np
import pandas as pd
from dataclasses import dataclass
from types import SimpleNamespace
from typing import Sequence, Any
from pyqstrat.strategy import Strategy
from pyqstrat.pq_types import Contract, ContractGroup, DEFAULT_CG
from pyqstrat.strategy import PriceFunctionType, StrategyContextType, MarketSimulatorType
from pyqstrat.strategy import RuleType, IndicatorType, SignalType
from pyqstrat.strategy_components import VectorSignal, VectorIndicator, SimpleMarketSimulator
from pyqstrat.pq_utils import assert_, get_child_logger


_logger = get_child_logger(__name__)


@dataclass
class StrategyBuilder:
    '''
    A helper class that makes it easier to build simpler strategies by removing the need for a lot of boilerplate code.
    The __call__ member function returns a Strategy built by this class that can then be run and evaluated.
    
    Args:
        data: A pandas dataframe containing columns for timestamps, indicators and signals
        timestamps: The ''heartbeat'' of the strategy. A vector of each relevant time for this strategy 
        timestamp_unit: Corresponds to bar length. Follows numpy datetime64 datatype strings.
            For example if you have daily bars, use M8[D] and if you have minute bars use M8[m]
        contract_groups: Each contract has to be a part of a contract group for PNL aggregation, etc. This class builds
            a contract group for each contract that is supplied to it, so this is only needed if you want to group contracts
        price_function: A function of type PriceFunctionType that we use to get market prices by contract name and timestamp
        pnl_calc_time: Since pnl is reported on a daily basis, this indicates the time (in minutes) for computing that PNL.
            For example, if you want to compute PNL at 4:01 pm each day, use 16 * 60 + 1
        starting_equity: Equity to start the backtest with
        trade_lag: How long it takes for an order to get to the market (in bars). If you are using input data from 2:33:44 pm
            it may take you less than one second to generate the order and send it to the market. In this case, assuming you 
            have 1 second bars, set the trade lag to 1. Market simulator get orders this many bars after the order is generated
            by trading rules. Trade lag of 0 can be used for daily orders, when you want to relax the assumption that
            it takes finite time to generate an order and send it to the market
        strategy_context: Properties that are passed into all user defined functions such as rule functions, signal functions.
            For example, you may want to set a property that indicates commission per trade instead of
            hardcoding it into a market simulator.
        indicators: Indicators are numeric vectors used to generate trading signals. For example, we may create an indicator 
            that has the overnight gap (difference between yesterday's closing price and this morning's open price)
        signals: Signals are boolean vectors used to determine whether or not we should run rules. For example, we may
            want to run an entry rule if the indicator above is more than 1% of last night's closing price. In this case
            the signal value for the corresponding time bar would be set to True
        rules: Rules are functions that take indicators and signals as inputs and generate orders as outputs at each time bar.
            Depending on the logic in each rule, it decides sizing, what kind of order to generate (limit, market, etc.) 
            and how many (or zero) orders to generate.
        market_sims: Market simulators simulate the execution of orders and generation of trades. The market sims are called
            in order so two market simulators should not successfully process the same order
    '''
    data: pd.DataFrame
    timestamps: np.ndarray | None
    timestamp_unit: np.dtype  # by default use minutes, unless set_timestamps is called
    contract_groups: dict[str, ContractGroup]
    price_function: PriceFunctionType | None
    pnl_calc_time: int
    starting_equity: float
    trade_lag: int
    strategy_context: SimpleNamespace
    indicators: list[tuple[str, IndicatorType, Sequence[ContractGroup] | None, Sequence[str] | None]]
    signals: list[tuple[str, SignalType, Sequence[ContractGroup] | None, Sequence[str] | None, Sequence[str] | None]]
    rules: list[tuple[str, RuleType, str, Sequence[Any] | None, str | None]]
    market_sims: list[MarketSimulatorType]
    log_trades: bool
    log_orders: bool
    
    def __init__(self, data: pd.DataFrame | None = None) -> None:
        if data is not None: assert_(len(data) > 0, 'data cannot be empty')
        self.data = data
        self.timestamps = None
        self.timestamp_unit = np.dtype('M8[m]')
        self.contract_groups = {}
        self.pnl_calc_time = 16 * 60 + 1
        self.starting_equity = 1.0e6
        self.trade_lag = True
        self.strategy_context = SimpleNamespace()
        self.indicators = []
        self.signals = []
        self.rules = []
        self.market_sims = []
        self.log_trades = True
        self.log_orders = False
        
    def set_timestamps(self, timestamps: np.ndarray) -> None:
        assert_(np.issubdtype(timestamps.dtype, np.datetime64), f'timestamps must be np.datetime64: {timestamps}')
        self.timestamps = timestamps
        
    def set_starting_equity(self, starting_equity: float) -> None:
        self.starting_equity = starting_equity
        
    def set_pnl_calc_time(self, pnl_calc_time: int) -> None:
        self.pnl_calc_time = pnl_calc_time
        
    def set_trade_lag(self, trade_lag: int) -> None:
        self.trade_lag = trade_lag
        
    def set_strategy_context(self, context: StrategyContextType) -> None:
        self.strategy_context = context
        
    def set_log_trades(self, log_trades: bool) -> None:
        self.log_trades = log_trades
        
    def set_log_orders(self, log_orders: bool) -> None:
        self.log_orders = log_orders
        
    def add_contract(self, symbol: str) -> Contract:
        if Contract.exists(symbol):
            contract = Contract.get(symbol)
            assert contract is not None  # keep mypy happy
        else:
            contract = Contract.create(symbol)
        return contract
        
    def set_price_function(self, price_function: PriceFunctionType) -> None:
        self.price_function = price_function
        
    def add_contract_group(self, contract_group: ContractGroup) -> None:
        self.contract_groups[contract_group.name] = contract_group
    
    def add_indicator(self, 
                      name: str, 
                      indicator: IndicatorType, 
                      contract_groups: Sequence[ContractGroup] | None = None, 
                      depends_on: Sequence[str] | None = None) -> None:
        self.indicators.append((name, indicator, contract_groups, depends_on))
        
    def add_series_indicator(self, name: str, column_name: str) -> None:
        assert_(column_name in self.data.columns, f'{column_name} not found in data')
        self.add_indicator(name, VectorIndicator(self.data[column_name].values))
        
    def add_signal(self,
                   name: str,
                   signal_function: SignalType,
                   contract_groups: Sequence[ContractGroup] | None = None,
                   depends_on_indicators: Sequence[str] | None = None,
                   depends_on_signals: Sequence[str] | None = None) -> None:
        self.signals.append((name, signal_function, contract_groups, depends_on_indicators, depends_on_signals))
        
    def add_rule(self,
                 name: str, 
                 rule_function: RuleType, 
                 signal_name: str,
                 sig_true_values: Sequence[Any] | None = None, 
                 position_filter: str | None = None) -> None:
        self.rules.append((name, rule_function, signal_name, sig_true_values, position_filter))
        
    def add_market_sim(self, market_sim_function: MarketSimulatorType) -> None:
        self.market_sims.append(market_sim_function)
        
    def add_series_rule(self,
                        column_name: str, 
                        rule_function: RuleType,
                        position_filter: str = '',
                        name: str = '',
                        contract_groups: list[ContractGroup] | None = None) -> None:
        '''
        Helper function that makes it easier to create a signal by using a boolean column from 
        the dataframe passed in the constructor to this class
        '''
        assert_(self.data is not None, 'data cannot be None when adding rule by name')
        assert_(column_name in self.data.columns, f'{column_name} not found in data: {self.data.columns}')
        dtype = self.data[column_name].dtype
        assert_(dtype == np.dtype('bool'), f'{column_name} expected to be boolean, got {dtype} instead')
        if len(name) == 0: name = column_name
        sig_name, rule_name = f'{name}_sig', f'{name}_rule'
        self.signals.append((sig_name, VectorSignal(self.data[column_name].values), contract_groups, None, None))
        self.rules.append((rule_name, rule_function, sig_name, None, position_filter))

    def __call__(self) -> Strategy:
        '''
        Generates a strategy object that we can then run and evaluate
        '''
        assert_(self.price_function is not None, 'price function must be set')
        if self.timestamps is None:
            assert_(self.data is not None, 'data cannot be None if timestamps is not set')
        _timestamps = self.data['timestamp'].values.astype(self.timestamp_unit) if self.timestamps is None else self.timestamps
        if len(self.contract_groups) == 0: 
            _contract_groups = [DEFAULT_CG]
        else:
            _contract_groups = list(self.contract_groups.values())
        
        strat = Strategy(_timestamps, 
                         _contract_groups, 
                         self.price_function,  # type: ignore
                         self.starting_equity, 
                         self.pnl_calc_time, 
                         self.trade_lag, 
                         True,
                         self.log_trades,
                         self.log_orders,
                         self.strategy_context)
        
        assert_(self.rules is not None and len(self.rules) > 0, 'rules cannot be empty or None')
        for name, indicator, contract_groups, depends_on in self.indicators:
            strat.add_indicator(name, indicator, contract_groups, depends_on)
             
        for name, signal_function, contract_groups, depends_on_inds, depends_on_sigs in self.signals:
            strat.add_signal(name, signal_function, contract_groups, depends_on_inds, depends_on_sigs)
            
        for name, rule_function, signal_name, sig_true_values, position_filter in self.rules:
            strat.add_rule(name, rule_function, signal_name, sig_true_values, position_filter)
        
        if not len(self.market_sims):
            strat.add_market_sim(SimpleMarketSimulator(self.price_function))  # type: ignore
        else:
            for market_sim in self.market_sims:
                strat.add_market_sim(market_sim)
            
        return strat
# $$_end_code
