"""Standard Imports"""
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime
from typing import List, Optional
from urllib.parse import urljoin

from pydantic import BaseModel
from requests import Response

from regscale.core.app.api import Api
from regscale.core.app.application import Application
from regscale.core.app.logz import create_logger
from regscale.core.app.utils.app_utils import convert_datetime_to_regscale_string


class Vulnerability(BaseModel):
    """Vulnerability Model"""

    id: Optional[int]
    uuid: Optional[str]
    scanId: Optional[int]
    parentId: Optional[int]
    parentModule: Optional[str]
    lastSeen: Optional[str]
    firstSeen: Optional[str]
    daysOpen: Optional[int]
    dns: Optional[str]
    ipAddress: Optional[str]
    mitigated: Optional[bool]
    operatingSystem: Optional[str]
    port: Optional[str]
    protocol: Optional[str]
    severity: Optional[str]
    plugInName: Optional[str]
    plugInId: Optional[int]
    cve: Optional[str]
    vprScore: Optional[int]
    exploitAvailable: Optional[bool]
    cvsSv3BaseScore: Optional[int]
    title: Optional[str]
    description: Optional[str]
    plugInText: Optional[str]
    createdById: Optional[str]
    lastUpdatedById: Optional[str]
    tenantsId: Optional[int] = 0
    dateCreated: Optional[str] = convert_datetime_to_regscale_string(datetime.now())
    dateLastUpdated: Optional[str] = convert_datetime_to_regscale_string(datetime.now())

    @classmethod
    def logger(cls):
        """Logger for Vulnerability Model"""
        logger = create_logger()
        return logger

    @staticmethod
    def post_vulnerability(vulnerability: "Vulnerability") -> dict:
        """Post a vulnerability to the API
        :param vulnerability: The vulnerability to be posted
        :return: The response from the API
        :rtype: dict
        """
        app = Application()
        api = Api(app)
        api_url = urljoin(app.config.get("domain"), "/api/vulnerability")
        payload = vulnerability.dict()
        response = api.post(url=api_url, json=payload)
        return response.json() if response.ok else response.raise_for_status()

    @staticmethod
    def post_vulnerabilities(app: Application, vulnerabilities: List["Vulnerability"]):
        """Insert new vulnerabilities into RegScale

        :param app: Application object
        :param vulnerabilities: List of Vulnerability objects
        :return: None
        :rtype: None
        """
        logger = create_logger()

        def post(url: str, dat: dict) -> Response:
            """Simple wrapper over a post command

            :param url: URL to post to
            :param dat: JSON data to post
            :return: Response object
            """
            res = api.post(url=url, json=dat)
            return res

        api = Api(app)
        logger.info("Posting %i new vulnerabilities in RegScale.", len(vulnerabilities))

        with ThreadPoolExecutor(max_workers=30) as executor:
            futures = [
                executor.submit(
                    post,
                    app.config["domain"] + "/api/vulnerability",
                    vuln.dict(),
                )
                for vuln in vulnerabilities
            ]
            grouped_responses = {}
            for future in as_completed(futures):
                result = future.result()
                status_code = result.status_code
                grouped_responses.setdefault(status_code, []).append(result)
            response_counts = {
                status_code: len(responses)
                for status_code, responses in grouped_responses.items()
            }
            logger.debug("Vulnerability Insert Response Counts: %s", response_counts)

    def __eq__(self, other):
        """Determine equaility of two Vulnerability objects

        :param other: Other Vulnerability object
        :return: True if equal, False if not
        :rtype: bool
        """
        if not isinstance(other, Vulnerability):
            # don't attempt to compare against unrelated types
            return NotImplemented

        return self.uuid == other.uuid

    @staticmethod
    def process_vulns(app: Application, new_vulns: List["Vulnerability"]):
        """Process Vulnerabilities

        :param app: Application Instance
        :param new_vulns: A list of new vulnerabilties
        :param existing_vulns: A list of existing vulnerabilities
        :return: None
        """

        # Filter Vulns
        Vulnerability.post_vulnerabilities(app=app, vulnerabilities=new_vulns)
