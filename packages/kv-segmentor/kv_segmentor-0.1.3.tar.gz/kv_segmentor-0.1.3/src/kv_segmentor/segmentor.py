from ultralytics import checks, YOLO
import cv2
import matplotlib.pyplot as plt
from typing import List


class Segmentor:
    def __init__(self,
                 model_path: str = "",
                 image_path: str = "",
                 image_size: int = 640,
                 confidence: float = .75,
                 save_txt: bool = False,
                 save_img: bool = False):
        """

        :param model_path: File path to the model weights file
        :param image_path: File path to the image to be segmented
        :param image_size: Image size used by the model, currently trained with 640
        :param confidence: Minimum confidence level (0-1.00)
        :param save_txt: Boolean to control whether the results should be saved in a .txt file
        :param save_img: Boolean to control whether the images are saved
        """

        self.model_path = model_path
        self.image_path = image_path
        self.image_size = image_size
        self.confidence = confidence
        self.save_txt = save_txt
        self.save_img = save_img
        self.model = None
        self.segmentation_results = None

        checks()  # Run Ultralytics.checks() to see the computational resources

    def load_model(self) -> None:
        """
        This function creates a You Only Look Once Ultralytics model using the provided model weights in the model_path.
        :return: None
        """
        self.model = YOLO(self.model_path)

    def get_image_size(self) -> (int, int):
        """
        This function gets the original images width and height (in pixels), which are used
        :return:  The width (w) and height (h) of the image
        """
        img = cv2.imread(self.image_path)
        h, w = img.shape[:2]

        return w, h

    def run_segmentation(self) -> None:
        """
        This function runs the provided image through the segmentation model, and stores the results in the results
        class variable.
        :return: None
        """

        results = self.model(source=self.image_path,
                             imgsz=self.image_size,
                             conf=self.confidence,
                             save_txt=self.save_txt,
                             save=self.save_img
                             )

        self.segmentation_results = results

    def get_segment_count(self) -> int:
        """
        This function returns
        :return: The number of segments in the image which meet the minimum confidence level.
        """

        return len(self.segmentation_results[0].boxes.xyxyn.numpy())

    def get_segment_coordinates(self) -> List:
        """
        This function extracts the x and y coordinates for the bounding boxes generated by the YOLO model inference
        and returns a List containing the bounding box coordinates for all segments.
        :return:
        """
        segments_coords = []
        img_w, img_h = self.get_image_size()  # get the height and width of the original image

        # Parse through the model generated boxes, and covert to the x and y coordinates of each bounding box

        for box in self.segmentation_results[0].boxes.xyxyn.numpy():  # use the normalized xy-xy values in numpy format
            segments_coords.append([(img_w * box[0]).astype(int),  # x1
                                    (img_h * box[1]).astype(int),  # y1
                                    (img_w * box[2]).astype(int),  # x2
                                    (img_h * box[3]).astype(int)])  # y2

        return segments_coords

    def snip_articles(self, dir_path: str = "") -> None:
        """
        This function snips each article from the page and saves it in a separate .png file.

        :param dir_path: Directory path where the snipped images should be saved
        :return: None
        """

        for cnt, article in zip(self.get_segment_coordinates(), self.segmentation_results):
            x1, y1, x2, y2 = article
            img = cv2.imread(self.image_path)
            snipit = img[y1:y2, x1:x2]

            if dir_path != "":
                plt.imsave(f"/{dir_path}/article_{cnt}.png", snipit)
            else:
                plt.imsave(f"article_{cnt}.png", snipit)

