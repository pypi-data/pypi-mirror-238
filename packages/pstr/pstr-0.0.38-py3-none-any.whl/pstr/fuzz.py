# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/07_fuzz.ipynb.

# %% auto 0
__all__ = ['fuzzfind']

# %% ../nbs/07_fuzz.ipynb 4
import difflib
from typing import Callable, Iterable

from atyp import Strs, IterStr
from ispec.utils import funkws

from .sens import sens

# %% ../nbs/07_fuzz.ipynb 6
def fuzzfind(string: str, strseq: IterStr, prep: bool = True, prepfunc: Callable = sens, **kwargs) -> Strs:
    '''Find the closest matches (same-ish) in the provided sequence using fuzzy matching.

    Parameters
    ----------
    string : str
        The string to find matches for.
    strseq : Iterable[str]
        The sequence of strings to find matches in.
    prep : bool, default: True
        Whether to call `prepfunc` on the provided string and the provided sequence, by default True
    prepfunc : Callable, default: sensify
        The function to call on the provided string and the provided sequence, by default sens
    
    Other Parameters
    ----------------
    n : int, default: 1
        The maximum number of matches to return.
    cutoff : float, default: 1
        The minimum score for a match to be returned.

    Notes
    -----
    `fuzzfind` is very similar to `difflib.get_close_matches`. However, it will call `prep` on the 
        provided string and the provided sequence.

    See Also
    --------
    sprep.sensify : The default `prepfunc` for `findsame`.
    difflib.get_close_matches : The function that `fuzzfind` is based on.
    '''
    
    pkws = funkws(prepfunc, **kwargs)
    doprep = lambda s: prepfunc(s, **pkws)

    string = doprep(string) if prep else string
    nmatch = kwargs.get('n', kwargs.get('nmatch', 1))
    cutoff = kwargs.get('cutoff', 1)
    
    strseq = strseq if isinstance(strseq, Iterable) else (strseq, )
    if prep: strseq = list(map(doprep, strseq))
 
    matches = difflib.get_close_matches(word=string, possibilities=strseq, n=nmatch, cutoff=cutoff)
    return matches
            
