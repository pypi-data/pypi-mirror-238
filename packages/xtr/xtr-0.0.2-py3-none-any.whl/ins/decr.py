# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_decr.ipynb.

# %% auto 0
__all__ = ['calldecr', 'callwith', 'callattr', 'attrfunc', 'chain']

# %% ../nbs/04_decr.ipynb 6
import copy
from functools import wraps
from inspect import ismethod

# %% ../nbs/04_decr.ipynb 8
from typing import Callable


# %% ../nbs/04_decr.ipynb 10
#| export


# %% ../nbs/04_decr.ipynb 12
from chck import isnone
from nlit import __DOC__, __NAME__, INPLACE
from idfunc import idfunc

# %% ../nbs/04_decr.ipynb 14
from .atyp import P, VArgs
from .args import tovargs, getbound

# %% ../nbs/04_decr.ipynb 16
def calldecr(dec: Callable, fn: Callable = None, /, *args, **kwargs):    
    if fn is None: return dec
    elif callable(fn): return dec(fn)(*args, **kwargs)
    else: raise TypeError(f"Expected callable, got {type(fn)}")

# %% ../nbs/04_decr.ipynb 17
def callwith(fn: Callable = None, /, *args, varg: tuple = None, vkws: dict = None,  **kwargs):
    def decorator(fn):
        @wraps(fn)
        def wrapper(*vargs, **vkwargs):
            barg, bkws = getbound(fn, *vargs, varg=varg, vkws=vkws, **vkwargs)
            return fn(*barg, **bkws)
        return wrapper
    return calldecr(decorator, fn, *args, **kwargs)    

# %% ../nbs/04_decr.ipynb 18
def callattr(obj, attr: str, *args: P.args, **kwargs: P.kwargs): 
    '''Call the `attr` of the `obj` filtering the given `args` and `kwargs` i.e. `obj.attr(*args, **kwargs).'''
    return callwith(getattr(obj, attr, idfunc), *args, **kwargs)

# %% ../nbs/04_decr.ipynb 19
def attrfunc(attr: str, *args, varg: tuple = None, vkws: dict = None, **kwargs):
    def decorator(fn: Callable):
        @wraps(fn, assigned=(__NAME__, __DOC__))
        def wrapper(x, *vargs, **vkwargs): 
            nonlocal attr
            if callable(fn) and isnone(attr): attr = fn.__name__
            return callattr(x, attr, *vargs, **vkwargs)
        return wrapper
    return calldecr(decorator, None, *args, **kwargs)

# %% ../nbs/04_decr.ipynb 23
class chain:
    
    methods = {}

    @classmethod
    def able(cls, fn: Callable):
        cls.methods.update({fn.__name__: fn})
        return fn
    
    def __init__(self, obj):
        self.obj = obj
        self._chain = []
    
    def chain(self, method: str, hush: bool = False):
        func = self.methods.get(method, idfunc)
        if func is idfunc and not hush: raise AttributeError(f'{method} not registered')
        self._chain.append(func)
        return self
        
    def __getattr__(self, attr): return self.chain(attr)
    def __call__(self, *args, **kwargs): return self
    
    def call(self, *args, **kwargs):
        obj = self.obj if kwargs.get(INPLACE, True) else copy.deepcopy(self.obj)
        for f in self._chain: obj = f(obj, *args, **kwargs)
        return obj
