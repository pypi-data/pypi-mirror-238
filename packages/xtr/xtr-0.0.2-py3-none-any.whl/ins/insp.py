# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_insp.ipynb.

# %% auto 0
__all__ = ['P', 'VArgs', 'getsig', 'getspec', 'hasvarargs', 'hasvarkwds', 'getbound', 'callwith', 'usearg0', 'getaidx',
           'argsadj0', 'getfargs', 'iskw', 'getfkwds', 'filtargs', 'filtcall', 'callattr', 'attr2fnc', 'callchain',
           'defargs', 'getdefs']

# %% ../nbs/01_insp.ipynb 6
import inspect
from inspect import Signature, Parameter, FullArgSpec, getfullargspec, signature, _empty as Empty, ismethod
from itertools import chain, zip_longest
from functools import wraps, partial

# %% ../nbs/01_insp.ipynb 8
from types import ModuleType
from typing import Any, Union, Tuple, TypeAlias, ParamSpec, Sequence, Callable

P = ParamSpec('P')
VArgs: TypeAlias = Union[Any, tuple]

# %% ../nbs/01_insp.ipynb 10
#| export


# %% ../nbs/01_insp.ipynb 12
from atyp import AnyQ, IntQ, BoolQ, Bool01, BoolFunc, CallQ
from chck import isany, istuple, isfunc, isvarpos, isvarkwd, isnone, notnone, isclsarg, isself
from nlit import __DOC__, __NAME__
from idfunc import idfunc

# %% ../nbs/01_insp.ipynb 14
from .nugs import renone, tovargs, jointups

# %% ../nbs/01_insp.ipynb 15
def getsig(f, retnone: bool = True) -> Signature:
    '''Alias for `inspect.signature(f)`'''
    return signature(f) if isfunc(f) else renone(Signature(), retnone)

def getspec(f, retnone: bool = True) -> FullArgSpec:
    '''Alias for `inspect.getfullargspec(f)`'''
    return getfullargspec(f) if isfunc(f) else renone(FullArgSpec(* ([None] * 7)), retnone)

def hasvarargs(f) -> bool: return notnone(getspec(f).varargs)

def hasvarkwds(f) -> bool: return notnone(getspec(f).varkw)

# %% ../nbs/01_insp.ipynb 16
def getbound(fn, *args, **kwargs):
    skeys = (sig := signature(fn)).parameters.keys()
    (bound := sig.bind_partial()).apply_defaults()
    varg, vkws = kwargs.pop('varg', None), kwargs.pop('vkws', None)
    k1st = list(skeys)[0]

    for name, value in zip(skeys, args):
        bound.arguments.update({name: value}) 

    if varg:
        for name, value in zip(skeys, varg):
            bound.arguments.update({name: value})

    bound.arguments.update(kwargs)
    if vkws: bound.arguments.update(vkws)

    if ismethod(fn) and k1st == 'cls':  bound.arguments.pop('cls',  None)
    if callable(fn) and k1st == 'self': bound.arguments.pop('self', None)
    return bound.args, bound.kwargs

# %% ../nbs/01_insp.ipynb 17
def callwith(fn=None, /, *dargs, varg=None, vkws=None, **dkwargs):
    def decorator(fn):
        @wraps(fn)
        def wrapper(*args, **kwargs):
            barg, bkws = getbound(fn, *args, varg=varg, vkws=vkws, **kwargs)
            return fn(*barg, **bkws)
        return wrapper
    if fn is None: return decorator
    elif callable(fn): return decorator(fn)(*dargs, **dkwargs)
    else: raise TypeError(f"Expected callable, got {type(fn)}")

# %% ../nbs/01_insp.ipynb 21
def usearg0(spec: FullArgSpec) -> bool:
    '''0 if `self` / 'cls` not included in spec.args'''
    if len(spec.args) >= 1 and spec.args[0] in {'self', 'cls'}: return True
    return False

def getaidx(spec: FullArgSpec, aidx: IntQ = None) -> Bool01:
    '''Get the arg index (`aidx`) to start at for the given spec'''
    return int(usearg0(spec)) if isnone(aidx) else aidx

def argsadj0(spec: FullArgSpec, aidx: IntQ = None, *args: P.args, **kwargs: P.kwargs):
    '''get args adjusted for `self` / `cls`'''
    # NOTE: if `self` or `cls` this will drop args from the end of the list
    aidx= getaidx(spec, aidx)
    args = spec.args if kwargs.get('retnames', False) else args
    # drop args from the end of the list
    start = kwargs.get('fromend', True)
    fargs = args[:len(spec.args) - aidx] if start else args[aidx:len(spec.args)]
    return fargs

def getfargs(spec: FullArgSpec, aidx: IntQ = None, *args: P.args, **kwargs: P.kwargs) -> tuple:
    '''Filter args and kwargs for the given `spec`'''
    return argsadj0(spec, aidx, *args, **kwargs)

def iskw(k: str, spec: FullArgSpec, aidx: IntQ = None, *args: P.args, **kwargs: P.kwargs) -> bool:
    '''Check if `k` is a kwarg in `spec` either as an optional keyword (in args) or as a kwonly arg'''  
    kwargs.update({'retnames': True})
    return k in argsadj0(spec, aidx, *args, **kwargs) or k in spec.kwonlyargs

def getfkwds(spec: FullArgSpec, aidx: IntQ = None, *args: P.args, **kwargs: P.kwargs) -> dict:
    # Filter keyword arguments
    fkwds = {k: v for k, v in kwargs.items() if iskw(k, spec, aidx, *args, **kwargs)}
    return fkwds

def filtargs(f: Callable, *args: P.args, **kwargs: P.kwargs) -> tuple:
    '''Filter args and kwargs for the given `fn`'''    
    aidx  = getaidx(spec := getspec(f))
    varg, vkws = kwargs.pop('varg', ()), kwargs.pop('vkws', dict())
    varg, vkws = jointups(varg, args), {**vkws, **kwargs}    
    fargs = list(getfargs(spec, aidx, *varg, **vkws))
    fkwds = getfkwds(spec, aidx, *varg, **vkws)
    kwargs.update({'retnames': True})
    names = argsadj0(spec, aidx, *args, **kwargs)
    for i, a in enumerate(names):
        if a not in fkwds: continue
        if i >= len(fargs): break
        fargs[i] = fkwds.pop(a)
    return tuple(fargs), fkwds

# %% ../nbs/01_insp.ipynb 23
def filtcall(fn: Callable, *args: P.args, **kwargs: P.kwargs):
    '''Filter args and kwargs for the given `fn` and then call it.'''
    fargs, fkwds = filtargs(fn, *args, **kwargs)
    return fn(*fargs, **fkwds)

def callattr(obj, attr: str, *args: P.args, **kwargs: P.kwargs): 
    '''Call the `attr` of the `obj` filtering the given `args` and `kwargs` i.e. `obj.attr(*args, **kwargs).'''
    return filtcall(getattr(obj, attr, idfunc), *args, **kwargs)

# %% ../nbs/01_insp.ipynb 24
def attr2fnc(attr: str):
    def decorator(fn: Callable):
        @wraps(fn, assigned=(__NAME__, __DOC__))
        def wrapper(x, *args, **kwargs): 
            return callattr(x, attr, *args, **kwargs)
        return wrapper
    return decorator

def callchain(x, funcs: Sequence[Callable], check: CallQ = None,  *args: P.args, **kwargs: P.kwargs):
    for f in funcs: 
        if notnone(check) and filtcall(check, x, *args, **kwargs): break
        x = filtcall(f, x, *args, **kwargs)
    return x

# %% ../nbs/01_insp.ipynb 25
def defargs(fn) -> tuple:
    '''Default args for the given function'''
    args = getsig(fn).parameters
    return tuple(darg if (darg := args.get(arg).default) != Empty else None for arg in args)

def getdefs(func: Callable, varg: tuple = None, kwds: dict = None, *args, **kwargs) -> Tuple[tuple, dict]:
    '''Get default arguments for the given function'''
    varg = varg or defargs(func)
    kwds = kwds or dict()
    fn_sig = getsig(func)
    anames = list(fn_sig.parameters.keys()) # argument names

    newvarg = list(jointups(varg, *args))
    newkwds = {**kwds, **kwargs}
    
    # Remove conflicting keys from newkwds
    for i, key in enumerate(anames[:len(newvarg)]):
        if (arg := newkwds.pop(key, None)) is not None:        
            newvarg[i] = arg
    
    bound = fn_sig.bind(*newvarg, **newkwds)
    bound.apply_defaults()
    return bound.args, bound.kwargs
