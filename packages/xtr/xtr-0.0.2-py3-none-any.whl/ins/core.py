# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/06_core.ipynb.

# %% auto 0
__all__ = ['P', 'VArgs', 'mat', 'attrfunc', 'applyfns', 'chain', 'nparr', 'tolist']

# %% ../nbs/06_core.ipynb 6
import inspect
from inspect import Signature, Parameter, FullArgSpec, getfullargspec, signature, _empty as Empty, ismethod
from itertools import chain, zip_longest
from functools import wraps, partial

# %% ../nbs/06_core.ipynb 8
from types import ModuleType
from typing import Any, Union, Tuple, TypeAlias, ParamSpec, Sequence, Callable

P = ParamSpec('P')
VArgs: TypeAlias = Union[Any, tuple]

# %% ../nbs/06_core.ipynb 10
#| export


# %% ../nbs/06_core.ipynb 12
from atyp import AnyQ, IntQ, BoolQ, Bool01, BoolFunc, CallQ
from chck import isany, istuple, isfunc, isvarpos, isvarkwd, isnone, notnone, isclsarg, isself
from nlit import __DOC__, __NAME__
from idfunc import idfunc

# %% ../nbs/06_core.ipynb 13
import numpy as np, pandas as pd, scipy

from atyp import StrQ, IntQ, NPArray, NPMatrix, Tensor, AnnData
from atyp import SPArray, SPMatrix, Index, Series, DataFrame

from chck import isad, isarr, ismtx, istens, issparse, istrc, isnone, notnone, isnpmatrix
from nlit import CPU, TOARRAY, TODENSE, TOLIST, DETACH, CLONE, NUMPY
from idfunc import idfunc

# %% ../nbs/06_core.ipynb 15
#| export


# %% ../nbs/06_core.ipynb 17
def attrfunc(attr: str, *args, varg=None, vkws=None, **kwargs):
    def decorator(fn: Callable):
        @wraps(fn, assigned=(__NAME__, __DOC__))
        def wrapper(x, *vargs, **vkwargs): 
            nonlocal attr
            if callable(fn) and isnone(attr): attr = fn.__name__
            return callattr(x, attr, *vargs, **vkwargs)
        return wrapper
    return calldecr(decorator, None, *args, **kwargs)

# %% ../nbs/06_core.ipynb 20
def applyfns(x, funcs: Sequence[Callable], *args: P.args, check: CallQ = None, **kwargs: P.kwargs):    
    for f in funcs: 
        if callable(check) and callwith(check, x, *args, **kwargs): break
        x = callwith(f, x, *args, **kwargs)
    return x

# %% ../nbs/06_core.ipynb 21
import copy
class chain:
    methods = {}    

    @classmethod
    def able(cls, fn):
        cls.methods.update({fn.__name__: fn})
        return fn
    
    def __init__(self, obj):
        self.obj = obj
        self._chain = []
    
    def chain(self, method, hush: bool = False):
        func = self.methods.get(method, idfunc)
        if func is idfunc and not hush: raise AttributeError(f'{method} not registered')
        self._chain.append(func)
        return self
        
    def __getattr__(self, attr):
        return self.chain(attr)
    
    def call(self, *args, **kwargs):
        obj = self.obj if kwargs.get('inplace', True) else copy.deepcopy(self.obj)
        for f in self._chain: obj = f(obj, *args, **kwargs)
        return obj
    
    def __call__(self, *args, **kwargs):
        return self
    

@chain.able
def nparr(a): return np.array(a)

@chain.able
@attrfunc(TOLIST)
def tolist(x):
    '''try: x.tolist() except: x'''

mat = np.matrix([1,2,3])
chain(mat).tolist().nparr().call()
chain(mat).tolist.nparr.do()
