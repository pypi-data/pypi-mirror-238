# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_args.ipynb.

# %% auto 0
__all__ = ['getbound']

# %% ../nbs/04_args.ipynb 6
from inspect import signature, ismethod, getfullargspec, Parameter, Signature

# %% ../nbs/04_args.ipynb 8
from types import ModuleType, FunctionType, BuiltinFunctionType
from typing import Any, Union, Tuple, Callable, Iterable, TypeAlias, ParamSpec, Sequence

# %% ../nbs/04_args.ipynb 10
#| export


# %% ../nbs/04_args.ipynb 12
from chck import isany, isdict, istuple, isnone, notnone, isditer, isrange, issig
from nlit import CLS, ARGS, SELF, KWARGS, VKWS, VARG

# %% ../nbs/04_args.ipynb 14
from .atyp import P, VArgs
from .tups import (argtup)

# %% ../nbs/04_args.ipynb 16
def getbound(fn: Callable, *args: P.args, default: Signature = Signature([]), **kwargs: P.kwargs):
    try:
        sig = signature(fn)
    except ValueError: # Handle built-in functions
        sig = default if issig(default) else Signature([])

    skeys = sig.parameters.keys()
    (bound := sig.bind_partial()).apply_defaults()
    varg, vkws = kwargs.pop(VARG, None), kwargs.pop(VKWS, None)
    k1st = list(skeys)[0] if len(list(skeys)) > 0 else None

    oarg, okws = bound.arguments.get(ARGS, ()), bound.arguments.get(KWARGS, dict())

    for name, value in zip(skeys, args):
        bound.arguments.update({name: value}) 

    if varg:
        for name, value in zip(skeys, varg):
            bound.arguments.update({name: value})

    bound.arguments.update(kwargs)
    if vkws: bound.arguments.update(vkws)

    if ismethod(fn) and k1st == CLS:  bound.arguments.pop(CLS,  None)
    if callable(fn) and k1st == SELF: bound.arguments.pop(SELF, None)
    
    if not isinstance(_a := bound.arguments.get(ARGS), tuple): 
        bound.arguments.update({ARGS: oarg or (_a, )})

    if not isinstance(_k := bound.arguments.get(KWARGS), dict): 
        bound.arguments.update({KWARGS: okws})

    return bound.args, bound.kwargs
