# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_args.ipynb.

# %% auto 0
__all__ = ['toargs', 'xargs', 'getbound']

# %% ../nbs/02_args.ipynb 6
from inspect import signature, ismethod

# %% ../nbs/02_args.ipynb 8
from types import ModuleType
from typing import Any, Union, Tuple, Callable, Iterable, TypeAlias, ParamSpec, Sequence

# %% ../nbs/02_args.ipynb 10
#| export


# %% ../nbs/02_args.ipynb 12
from chck import isany, isdict, istuple, isnone, notnone, isditer, isrange
from nlit import CLS, ARGS, SELF, KWARGS, VKWS, VARG

# %% ../nbs/02_args.ipynb 14
from .atyp import P, VArgs
from .util import (val2tup, tup2args, dct2args, rng2args)

# %% ../nbs/02_args.ipynb 16
def toargs(*args: VArgs) -> tuple:
    '''Wrangle `*args` into a tuple of arguments
    
    Examples
    --------
    >>> Recursive deconstruction
    >>> toargs(1), toargs((1, )), toargs(((1, ), ))
    ((1,), (1,), (1,))

    >>> # Deconstruct only the first argument, tuples ok at other positions
    >>> toargs(1, 2), toargs('a', (1, )), toargs('a', 1, ), toargs(*['a'])
    ((1, 2), ('a', (1,)), ('a', 1), ('a',))

    >>> # handle unpacking
    >>> toargs([]), toargs(*[])
    (([],), ())

    See Also
    --------
    `xargs` : Alias for `toargs`    
    '''
    return val2tup(tup2args(dct2args(rng2args(args))))

def xargs(*args: VArgs) -> tuple:
    '''Wrangle `*args` into a tuple of arguments
    
    Examples
    --------
    >>> Recursive deconstruction
    >>> toargs(1), toargs((1, )), toargs(((1, ), ))
    ((1,), (1,), (1,))

    >>> # Deconstruct only the first argument, tuples ok at other positions
    >>> toargs(1, 2), toargs('a', (1, )), toargs('a', 1, ), toargs(*['a'])
    ((1, 2), ('a', (1,)), ('a', 1), ('a',))

    >>> # handle unpacking
    >>> toargs([]), toargs(*[])
    (([],), ())

    See Also
    --------
    `toargs` : Alias for `xargs`
    '''
    return toargs(*args)

# %% ../nbs/02_args.ipynb 17
def getbound(fn: Callable, *args: P.args, **kwargs: P.kwargs):
    # try:
    skeys = (sig := signature(fn)).parameters.keys()
    (bound := sig.bind_partial()).apply_defaults()
    # except ValueError: # Handle built-in functions        
    varg, vkws = kwargs.pop(VARG, None), kwargs.pop(VKWS, None)
    k1st = list(skeys)[0] if len(list(skeys)) > 0 else None

    oarg, okws = bound.arguments.get(ARGS, ()), bound.arguments.get(KWARGS, dict())

    for name, value in zip(skeys, args):
        bound.arguments.update({name: value}) 

    if varg:
        for name, value in zip(skeys, varg):
            bound.arguments.update({name: value})

    bound.arguments.update(kwargs)
    if vkws: bound.arguments.update(vkws)

    if ismethod(fn) and k1st == CLS:  bound.arguments.pop(CLS,  None)
    if callable(fn) and k1st == SELF: bound.arguments.pop(SELF, None)
    
    if not isinstance(_a := bound.arguments.get(ARGS), tuple): 
        bound.arguments.update({ARGS: oarg or (_a, )})

    if not isinstance(_k := bound.arguments.get(KWARGS), dict): 
        bound.arguments.update({KWARGS: okws})

    return bound.args, bound.kwargs
