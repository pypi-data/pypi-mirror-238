# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_call.ipynb.

# %% auto 0
__all__ = ['calldecr', 'callwith', 'callattr', 'attrfunc', 'applyfns', 'chain']

# %% ../nbs/05_call.ipynb 6
import copy
from functools import wraps
from inspect import ismethod

# %% ../nbs/05_call.ipynb 8
from typing import Callable, Sequence

# %% ../nbs/05_call.ipynb 10
#| export


# %% ../nbs/05_call.ipynb 12
from atyp import CallQ, DictQ, TupleQ
from chck import isnone
from nlit import __DOC__, __NAME__, INPLACE
from idfunc import idfunc

# %% ../nbs/05_call.ipynb 14
from .atyp import P, VArgs
from .args import getbound

# %% ../nbs/05_call.ipynb 16
def calldecr(dec: Callable, fn: CallQ = None, /, *args: P.args, **kwargs: P.kwargs) -> Callable:
    if fn is None: return dec
    elif callable(fn): return dec(fn)(*args, **kwargs)
    else: raise TypeError(f"Expected callable, got {type(fn)}")

# %% ../nbs/05_call.ipynb 17
def callwith(fn: CallQ = None, /, *args: P.args, varg: TupleQ = None, vkws: DictQ = None,  **kwargs: P.kwargs):
    def decorator(fn):
        @wraps(fn)
        def wrapper(*vargs: P.args, **vkwargs: P.kwargs):
            barg, bkws = getbound(fn, *vargs, varg=varg, vkws=vkws, **vkwargs)
            return fn(*barg, **bkws)
        return wrapper
    return calldecr(decorator, fn, *args, **kwargs)    

# %% ../nbs/05_call.ipynb 18
def callattr(obj, attr: str, *args: P.args, **kwargs: P.kwargs): 
    '''Call the `attr` of the `obj` filtering the given `args` and `kwargs` i.e. `obj.attr(*args, **kwargs).'''
    return callwith(getattr(obj, attr, idfunc), *args, **kwargs)

# %% ../nbs/05_call.ipynb 19
def attrfunc(attr: str, *args: P.args, varg: TupleQ = None, vkws: DictQ = None, **kwargs: P.kwargs):
    def decorator(fn: Callable):
        @wraps(fn, assigned=(__DOC__, __NAME__))
        def wrapper(x, *vargs, **vkwargs): 
            nonlocal attr
            if callable(fn) and isnone(attr): attr = fn.__name__
            return callattr(x, attr, *vargs, **vkwargs)
        return wrapper
    return calldecr(decorator, None, *args, **kwargs)

# %% ../nbs/05_call.ipynb 23
def applyfns(x, funcs: Sequence[Callable], *args: P.args, check: CallQ = None, **kwargs: P.kwargs):    
    for f in funcs: 
        if callable(check) and callwith(check, x, *args, **kwargs): break
        x = callwith(f, x, *args, **kwargs)
    return x

# %% ../nbs/05_call.ipynb 25
class chain:
    methods = {}
    @classmethod
    def able(cls, fn: Callable):
        cls.methods.update({fn.__name__: fn})
        return fn
    
    def __init__(self, obj):
        self.obj = obj
        self._chain = []
    
    def chain(self, method: str, hush: bool = False):
        func = self.methods.get(method, idfunc)
        if func is idfunc and not hush: raise AttributeError(f'{method} not registered')
        self._chain.append(func)
        return self
        
    def __getattr__(self, attr): return self.chain(attr)
    def __call__(self, *args, **kwargs): return self
    
    def call(self, *args, **kwargs):
        obj = self.obj if kwargs.get(INPLACE, True) else copy.deepcopy(self.obj)
        for f in self._chain: obj = f(obj, *args, **kwargs)
        return obj
